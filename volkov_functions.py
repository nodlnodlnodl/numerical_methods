import streamlit as st
import numpy as np
import matplotlib.pyplot as plt
from streamlit_ace import st_ace
from code_editor import code_editor

from scipy.integrate import odeint
from scipy.optimize import fsolve

import io
import sys


# 3.3 Интерполяция сплайнами
def interpolation_by_splines():
    st.header("""3.3. Интерполяция сплайнами""")
    st.markdown("""
        Интерполяция сплайнами — это метод, который позволяет получить более точную интерполяцию функции по сравнению с 
        многочленами высокой степени, за счёт построения полиномов на отдельных отрезках между узлами. В основе этого
        метода лежит построение так называемых 'плавающих' многочленов, которые определяются для промежутков между 
        соседними узлами. Обычно используются полиномы третьей степени, так называемые кубические сплайны.
    """)

    st.latex(r"""
        \textbf{Кубический сплайн на отрезке} \, [x_{i-1}, x_i] \, представляется \, в \, виде: \\
        P_i(x) = a_i + b_i (x - x_{i-1}) + c_i (x - x_{i-1})^2 + d_i (x - x_{i-1})^3
    """)

    st.markdown("""
        Для того чтобы сплайн был гладким, необходимо выполнение условий стыковки полиномов в узлах:
    """)

    st.latex(r"""
        \textbf{Условия стыковки:}
        \begin{align*}
            P_i(x_i) &= P_{i+1}(x_i) \\
            P_i'(x_i) &= P_{i+1}'(x_i) \\
            P_i''(x_i) &= P_{i+1}''(x_i)
        \end{align*}
    """)

    st.markdown("""
        Эти условия необходимы для того, чтобы обеспечить непрерывность функции и её первых двух производных в узлах 
        интерполяции. Система линейных уравнений для коэффициентов $$ a_i, b_i, c_i, d_i $$ составляется на основе этих 
        условий и решается для каждого узла.

        В дополнение к условиям стыковки, нужно задать граничные условия. Одним из наиболее распространённых граничных 
        условий является равенство второй производной функции на концах интервала к нулю, что даёт так называемый 
        естественный сплайн:
    """)

    st.latex(r"""
        \textbf{Граничные условия:}
        \begin{align*}
            P_1''(x_0) &= 0 \\
            P_N''(x_N) &= 0
        \end{align*}
    """)

    st.markdown("""
        После применения граничных условий система уравнений выглядит следующим образом:
    """)

    st.latex(r"""
        \text{Система уравнений для коэффициентов} \, c_i:
        \begin{align*}
            a_i &= y_i \\
            b_i &= \frac{y_{i+1} - y_i}{h_i} - \frac{h_i}{3}(2c_i + c_{i+1}) \\
            d_i &= \frac{c_{i+1} - c_i}{3h_i} \\
            c_1 &= 0, \, c_N = 0
        \end{align*}
    """)

    st.markdown("""
        Теперь, используя эти формулы, можно вычислить значения функции в любом месте интервала между узлами. Давайте
         реализуем это на Python и посмотрим, как работает кубическая интерполяция сплайнами.
    """)

    st.markdown("""
        **Реализация сплайновой интерполяции на Python:**
    """)

    st.code("""
    import numpy as np
    import matplotlib.pyplot as plt
    
    def f(x):
        return np.sin(x)
        
    # Входные данные
    x_points = [0, 2, 4, 6, 8, 10]
    y_points = f(x_points)

    # Функция для решения системы линейных уравнений методом Гаусса
    def solve_gaussian(A, b):
        n = len(b)
        # Прямой ход метода Гаусса
        for i in range(n):
            # Выбор ведущего элемента
            max_row = max(range(i, n), key=lambda r: abs(A[r][i]))
            A[i], A[max_row] = A[max_row], A[i]
            b[i], b[max_row] = b[max_row], b[i]
    
            for j in range(i + 1, n):
                factor = A[j][i] / A[i][i]
                b[j] -= factor * b[i]
                for k in range(i, n):
                    A[j][k] -= factor * A[i][k]
    
        # Обратный ход метода Гаусса
        x = [0] * n
        for i in range(n - 1, -1, -1):
            x[i] = (b[i] - sum(A[i][j] * x[j] for j in range(i + 1, n))) / A[i][i]
        return x
    
    # Функция для расчёта коэффициентов кубического сплайна
    def cubic_spline(x_points, y_points):
        n = len(x_points)
        h = [x_points[i+1] - x_points[i] for i in range(n-1)]
        
        # Матрица для системы уравнений
        A = [[0] * n for _ in range(n)]
        b = [0] * n
    
        A[0][0] = A[n-1][n-1] = 1  # Граничные условия
        for i in range(1, n-1):
            A[i][i-1] = h[i-1]
            A[i][i] = 2 * (h[i-1] + h[i])
            A[i][i+1] = h[i]
            b[i] = 3 * ((y_points[i+1] - y_points[i]) / h[i] - (y_points[i] - y_points[i-1]) / h[i-1])
        
        # Решаем систему линейных уравнений для нахождения коэффициентов c
        c = solve_gaussian(A, b)
    
        # Нахождение коэффициентов a, b, d
        a = [y_points[i] for i in range(n-1)]
        b = [(y_points[i+1] - y_points[i])/h[i] - h[i]*(2*c[i] + c[i+1])/3 for i in range(n-1)]
        d = [(c[i+1] - c[i]) / (3*h[i]) for i in range(n-1)]
        
        return a, b, c, d
        """)

    # Функция для расчёта значения функции
    def f(x):
        return np.sin(x)

    # Функция для кубической интерполяции сплайнами
    def cubic_spline(x_points, y_points):
        n = len(x_points)
        h = [x_points[i + 1] - x_points[i] for i in range(n - 1)]

        # Система уравнений для коэффициентов c_i
        A = np.zeros((n, n))
        b = np.zeros(n)

        A[0, 0] = A[n - 1, n - 1] = 1
        for i in range(1, n - 1):
            A[i, i - 1] = h[i - 1]
            A[i, i] = 2 * (h[i - 1] + h[i])
            A[i, i + 1] = h[i]
            b[i] = 3 * ((y_points[i + 1] - y_points[i]) / h[i] - (y_points[i] - y_points[i - 1]) / h[i - 1])

        c = np.linalg.solve(A, b)

        # Нахождение коэффициентов a, b, d
        a = [y_points[i] for i in range(n - 1)]
        b = [(y_points[i + 1] - y_points[i]) / h[i] - h[i] * (2 * c[i] + c[i + 1]) / 3 for i in range(n - 1)]
        d = [(c[i + 1] - c[i]) / (3 * h[i]) for i in range(n - 1)]

        return a, b, c, d

    # Функция для вычисления значения кубического сплайна
    def spline_value(x_val, x, a, b, c, d):
        for i in range(len(x) - 1):
            if x[i] <= x_val <= x[i + 1]:
                dx = x_val - x[i]
                return a[i] + b[i] * dx + c[i] * dx ** 2 + d[i] * dx ** 3
        return None

    # Выбор количества узлов через слайдер
    n_points = st.slider("Выберите количество узлов интерполяции", 2, 12, 6)

    # Узлы интерполяции и значения функции в этих узлах
    x_points = np.linspace(0, 10, n_points)
    y_points = f(x_points)

    # Рассчитываем коэффициенты сплайнов
    a, b, c, d = cubic_spline(x_points, y_points)

    # Интервал для отображения графика
    x_range = np.linspace(0, 10, 1000)
    y_spline = [spline_value(x, x_points, a, b, c, d) for x in x_range]

    # Визуализация графиков
    fig, ax = plt.subplots()
    ax.plot(x_range, f(x_range), label="Исходная функция")
    ax.plot(x_range, y_spline, label="Приближение сплайнами")
    ax.scatter(x_points, y_points, color='red', label='Узлы интерполяции')
    ax.legend()

    st.pyplot(fig)


# 4.1. Численное дифференцирование
def numerical_differentiation():
    st.header("4.1. Численное дифференцирование")

    st.markdown("""
        Численное дифференцирование применяется тогда, когда функцию $$ y(x) $$ невозможно (или трудно) 
        продифференцировать аналитически. Это часто бывает в случае таблично заданных функций или при решении 
        дифференциальных уравнений с конечными разностями.

        Основная идея численного дифференцирования заключается в том, что функцию $$ y(x) $$ аппроксимируют с помощью 
        интерполяционных многочленов или других методов, для которых легко вычислить производную.

        Для численного дифференцирования можно использовать следующий подход: аппроксимировать функцию $$ y(x) $$ 
        некоторой функцией $$ φ(x) $$, производную которой легко вычислить, и затем полагать, что:
    """)

    st.latex(r"""
        y'(x) \approx \varphi'(x)
    """)

    st.markdown("""
        В качестве аппроксимирующих функций широко используются интерполирующие многочлены.
    """)


# 4.1.1. Получение формул дифференцирования на основе многочлена Ньютона
def numerical_differentiation_newton_polynomial():
    st.header("4.1.1. Получение формул дифференцирования на основе многочлена Ньютона")

    st.markdown("""
    Пусть в точках $$ x_1, \dots, x_{n+1} $$ известны значения $$ y_1, \dots, y_{n+1} $$ функции $$ y(x) $$.
    Для этих узлов интерполирующий многочлен в форме Ньютона имеет вид:
    """)

    st.latex(r"""
            P_n(x) = y_1 + (x - x_1)\: ([x_2, x_1] + (x - x_2)\: [x_3, x_2, x_1] + \dots)\tag 1
        """)

    st.markdown("""
    где разделённые разности вычисляются по формулам:
    """)

    st.latex(r"""
        [x_2, x_1] = \frac{y_2 - y_1}{x_2 - x_1};
    """)

    st.latex(r"""
        [x_3, x_2, x_1] = \frac{[x_3, x_2] - [x_2, x_1]}{x_3 - x_1}=\frac1{x_3 - x_1}\left[\frac{y_3 - y_2}{x_3 - x_2} 
        - \frac{y_2 - y_1}{x_2 - x_1}\right];
    """)

    st.latex(r"""
        [x_1, \dots, x_n] = \frac{[x_2, \dots, x_n] - [x_1, \dots, x_{n-1}]}{x_n - x_1}.
    """)

    st.markdown("""
    Из формулы (1) получаем (введем обозначение $$ t_i = x - x_i $$):
    """)

    st.latex(r"""
        P_n'(x) = [x_1, x_2] + (t_1 + t_2) [x_1, x_2, x_3] + t_1 t_2 [x_1, x_2, x_3, x_4] + \dots,
    """)

    st.latex(r"""
        P_n''(x) = 2[x_1, x_2, x_3] + 2(t_1 + t_2 + t_3) [x_1, x_2, x_3, x_4] + \dots,\tag 2
    """)

    st.latex(r"""
        P_n^{(k)}(x) = k! \left( [x_1, \dots, x_{k+1}] +  \left( \sum_{i=1}^{k+1} t_j \right) [x_1, \dots, x_{i+1}]+ 
        \dots \right).
    """)

    st.markdown("""
    Обрезая эти формулы на некотором числе членов, получаем более простые приближённые формулы для производных. Обычно 
    ограничиваются только первыми слагаемыми. Выпишем некоторые простейшие употребительные одночленные формулы:
    """)

    st.markdown("""
    ### Простейшие одночленные формулы:
    """)

    st.latex(r"""
        y'(x) = \frac{y_2 - y_1}{x_2 - x_1};
    """)

    st.latex(r"""
        \frac{1}{2} y''(x) = \frac1{x_3 - x_1}\left[\frac{y_3 - y_2}{x_3 - x_2} - \frac{y_2 - y_1}{x_2 - x_1}\right];
        \tag 3
    """)

    st.latex(r"""
    \frac{1}{k!}y^{(k)}(x)=[x_1,\dots,x_{k+1}].
    """)

    st.markdown("""
    Получим оценки погрешности приближённых формул дифференцирования (2). Очевидно, имеем:
    """)

    st.latex(r"""
        y(x) = P_n(x) + R_n(x),
    """)

    st.markdown("""
    где $$ R_n(x) $$ — погрешность интерполяции. Следовательно:
    """)

    st.latex(r"""
        y^{(k)}(x) = P_n^{(k)}(x) + R_n^{(k)}(x),
    """)

    st.markdown("""
    т.е. погрешность производной равна производной от погрешности интерполяции. Погрешность интерполяционной формулы
     имеет вид (если использованы узлы $$ x_1, \dots, x_{n+1} $$):
    """)

    st.latex(r"""
        R_n(x) = \frac{(x - x_1)(x - x_2) \dots (x - x_n)}{(n+1)!} y^{(n+1)}(\overline x),
    """)

    st.markdown("""
    тогда $$ R_n^{(k)}(x) $$ будет содержать сумму $$ (n+1) n (n-1) \dots [n+1 - (k - 1)] $$ произведений $$ n+1-k $$ 
    множителей $$ t_i $$:
    """)

    st.latex(r"""
        |R_n^{(k)}(x)| \leq \frac{M_{n+1}}{(n+1-k)!}\max_i \left| t_i \right|^{n+1-k},
    """)

    st.markdown("""
    где:
    """)

    st.latex(r"""
        M_{n+1} = \max_x \left| y^{(n+1)}(x) \right|.
    """)

    st.markdown("""
    Если все узлы расположены равномерно, т.е. $$ x_{i+1} - x_i = h $$ для всех $$ i $$, то $$ \max |t_i| = nh $$ и
    """)

    st.latex(r"""
        |R_n^{(k)}(x)| \leq L_{n+1} h^{n+1-k}.
    """)

    st.markdown("""
    Таким образом, порядок точности формул (2) по отношению к шагу $$ h $$ равен числу узлов интерполяции минус порядок
     производной. Поэтому для вычисления $$ k $$-й производной требуется, как минимум, $$ (k+1) $$ узел, при этом 
     получаются формулы вида (3), имеющие первый порядок точности.
    """)

    st.markdown("""
    ### Точка повышенной точности
    """)

    st.markdown("""
    Для одночленных формул вида (3) корни используются из условия:
    """)

    st.latex(r"""
        \sum_{i=1}^{k+1} (x - x_i) = 0,
    """)

    st.markdown("""
    т.е. точка повышенной точности есть:
    """)

    st.latex(r"""
        x = \frac{1}{k+1} (x_1 + \dots + x_{k+1}).
    """)

    st.markdown("""
    В этой точке формулы (3) имеют точность $$ O(h^2) $$, а не $$ O(h) $$.

    Если в формулах (2) оставить по два слагаемых, то для определения точки повышенной точности получим квадратное 
    уравнение. Для большого числа слагаемых найти точку повышенной точности уже сложно. Однако есть один простой частный
     случай, для которого точка повышенной точности в формулах (2) легко указывается.
    """)

    st.markdown("""
    ### Теорема 1
    """)

    st.markdown("""
    Пусть $$ n+1-k $$ — нечетное число, и точки $$ x_1, \dots, x_{k+1} $$ выбраны так, что они лежат симметрично 
    относительно $$ x $$, тогда $$ x $$ — точка повышенной точности для производной $$ k $$-го порядка (2).
    """)

    st.markdown("""
    ### Доказательство
    """)

    st.markdown("""
    Очевидно, величины $$ t_i = x - x_i $$ будут попарно равны по абсолютной величине и будут иметь разные знаки. 
    Остаточный многочлен $$ R_n^{(k)}(x) $$ имеет степень $$ n+1-k $$, по условию нечетную, и имеет вид 
    $$ \sum\prod (t_i) $$.

    Поэтому, если сменить знак у всех $$ t_i $$, то $$ R_n^{(k)}(x) $$ должен также сменить знак. Но так как при этом 
    производные лишь перенумеруются, то они не должны измениться. Это возможно лишь при $$ R_n^{(k)}(x) = 0 $$, что и 
    требовалось доказать.
    """)

    st.markdown("""
    При произвольном расстановке узлов условие симметрии реализуется в исключительных случаях. При равномерной 
    расстановке фактически каждый узел (за исключением близких к краям) окружен симметрично другими узлами. Поэтому для 
    этих узлов можно написать простые формулы хорошей точности.
    """)

    st.markdown("""
    Пусть $$ x_{i+1} - x_i = h $$, напишем формулы по трем узлам $$ x_1, x_2, x_3 $$ для производных в среднем узле:
    """)

    st.latex(r"""
        y'_2 = \frac{y_3 - y_1}{2h} + O(h^2);
    """)

    st.latex(r"""
            y'_2 = \frac{y_3 - 2y_2 + y_1}{h^2} + O(h^2). \tag 4
        """)

    st.markdown("""
    Очевидно, что:
    """)

    st.latex(r"""
        y'(x_{i+1/2}) = y'(x_i + h/2) = \frac{y_{i+1} - y_i}{h}, \quad h = x_{i+1} - x_i
    """)

    st.markdown("""
    также имеет повышенную точность.
    """)

    st.markdown("""
    ### Пример вычисления производной
    """)

    st.markdown("""
    Рассмотрим четыре узла $$ x_1, x_2, x_3, x_4 $$ и вычислим производную при:
    """)

    st.latex(r"""
        x_{5/2} = \frac{x_2 + x_3}{2}
    """)

    st.latex(r"""
        y'_{5/2} = \frac{-y_4 + 27y_3 - 27y_2 + y_1}{24h},
    """)

    st.markdown("""
    Её точность будет $$ O(h^4) $$.

    ### Вторая производная

    Рассмотрим пять узлов $$ x_1, x_2, x_3, x_4, x_5 $$ и вычислим вторую производную $$ y''(x_3) $$ при:
    """)

    st.latex(r"""
        y''_n = \frac{-y_5 + 16y_4 - 30y_3 + 16y_2 - y_1}{12h^2}
    """)

    st.markdown("""
    Её точность также $$ O(h^4) $$.
    """)

    # Функция для разделённых разностей
    def divided_differences(x, y):
        n = len(y)
        coef = [y.copy()]  # Первое значение — это сами y
        for j in range(1, n):
            coef.append([(coef[j - 1][i + 1] - coef[j - 1][i]) / (x[i + j] - x[i]) for i in range(n - j)])
        return [row[0] for row in coef]

    # Функция для вычисления значения многочлена Ньютона в точке x_val
    def newton_polynomial(x, coef, x_val):
        n = len(coef)
        result = coef[-1]
        for i in range(n - 2, -1, -1):
            result = coef[i] + (x_val - x[i]) * result
        return result

    # Производная многочлена Ньютона
    def newton_polynomial_derivative(x, coef, x_val):
        n = len(coef)
        derivative = 0
        for i in range(n - 1):
            term = coef[i]
            for j in range(i):
                term *= (x_val - x[j])
            derivative += term
        return derivative

    #  функция f(x)
    def f(x):
        return x ** 3 * np.sin(x) + 2 * x ** 2

    # Производная функции f'(x) для сравнения
    def f_prime(x):
        return 3 * x ** 2 * np.sin(x) + x ** 3 * np.cos(x) + 4 * x

    # Входные данные: узлы и их значения
    x_nodes = [1, 2, 3, 4, 5]
    y_nodes = [f(x) for x in x_nodes]

    # Получение коэффициентов для многочлена Ньютона
    coef = divided_differences(x_nodes, y_nodes)

    # Точка повышенной точности
    x_central = sum(x_nodes) / len(x_nodes)

    # Вычисление значений для построения графика
    x_vals = [i * 0.05 for i in range(10, 110)]
    y_vals = [f(x) for x in x_vals]
    poly_vals = [newton_polynomial(x_nodes, coef, x) for x in x_vals]
    poly_prime_vals = [newton_polynomial_derivative(x_nodes, coef, x) for x in x_vals]

    # Построение графиков
    plt.figure(figsize=(10, 6))

    # Исходная функция
    plt.plot(x_vals, y_vals, label='Исходная функция $f(x) = x^3 \cdot \sin(x) + 2x^2$', color='blue')

    # Интерполяционный многочлен
    plt.plot(x_vals, poly_vals, label='Интерполяционный многочлен Ньютона', color='orange')

    # Производная
    plt.plot(x_vals, poly_prime_vals, label="Производная многочлена Ньютона", linestyle="--", color='green')

    # Узлы интерполяции
    plt.scatter(x_nodes, y_nodes, color='red', label='Узлы интерполяции')

    # Точка повышенной точности
    plt.axvline(x_central, color='purple', linestyle=':', label='Точка повышенной точности')

    # Настройки графика
    plt.title("Иллюстрация Теоремы 1: Симметричные узлы и точка повышенной точности")
    plt.xlabel("x")
    plt.ylabel("y")
    plt.legend()
    plt.grid(True)

    # Отображение графика
    st.pyplot(plt)

    st.markdown("""
    ### Замечание

    Для равноотстоящих узлов при оценке точности формул численного дифференцирования часто используют разложение 
    $$ y(x) $$ в ряд Тейлора вблизи рассматриваемой точки $$ x $$.

    Рассмотрим, например, формулу (4) для второй производной $$ y''(x_2) $$.
    """)

    st.latex(r"""
        y_{2\pm1} = y(x_2 \pm h) = y_2 \pm h y_2' + \frac{h^2}{2} y''(x_2)\pm \frac{h^3}{6} y''' + 
        \frac{h^4}{24} y^{(4)}(\overline x_\pm)\tag{5}
    """)

    st.latex(r"""
     где,\  x_1 < \bar x_+ < x_3,\  x_1 < \bar x_- < x_3 \text { — некоторые точки}.
    """)

    st.markdown("""
    Подставив это разложение в формулу (4), получим:
    """)

    st.latex(r"""
        \frac{y_3 - 2y_2 + y_1}{h^2} = y_2'' + \frac{h^2}{24} \left[y^{(4)}(\bar x_+) + y^{(4)}(\bar x_-) \right]= y_2''
         + \frac{h^2}{12} y^{(4)} 
    """)

    st.markdown("""
    Этот же метод рядов Тейлора применяется и для получения формул дифференцирования с помощью неопределённых 
    коэффициентов.

    Получим, например, формулу (4) для $$ y_2'(x) $$ по узлам $$ x_1, x_2, x_3 $$.

    Предположим, что:
    """)

    st.latex(r"""
    y_2'=a_1 y_1 + a_2 y_2 + a_3 y_3\tag{6}
    """)

    st.markdown("""где, $$a_1, a_2, a_3$$ - неопределенные коэффициенты. Подставляя вместо $$y_1,y_3$$ их выражения 
    через ряд (5), получим
    """)

    st.latex(r"""
        a_1 y_1 + a_2 y_2 + a_3 y_3 = a_1 \left[y_2 - h y_2' + \frac{h^2}{2} y_2'' - \frac{h^3}{6} y_2''' + 
        \frac{h^4}{24} y_2^{(4)}(\bar x_-) \right]+
    """)

    st.latex(r"""
        + a_2 y_2 + a_3 \left[ y_2 + h y_2' + \frac{h^2}{2} y_2'' + \frac{h^3}{6} y_2''' +
        \frac{h^4}{24} y_2^{(4)}(\bar x_+) \right]=
    """)

    st.latex(r"""
        = (a_1 + a_2 + a_3) y_2 + h y_2' (a_3 - a_1) + \frac{h^2}{2} y_2'' (a_3 + a_1) + 
        \frac{h^3}{6} y_2''' (a_3 - a_1)  + O(h^4)
    """)

    st.markdown("""
    Мы хотим обеспечить условия, при которых сумма в правой части (6) приближает $$ y_2' $$ с возможно 
    меньшей погрешностью. Поэтому для $$ a_i $$ получаем уравнения:
    """)

    st.latex(r"""
        a_1 + a_2 + a_3 = 0;
    """)

    st.latex(r"""
        h (a_3 - a_1) = 1;
    """)

    st.latex(r"""
        a_3 + a_1 = 0;
    """)

    st.markdown("""
    Отсюда:
    """)

    st.latex(r"""
        a_3 = -a_1 = \frac{1}{2h}, \quad a_2 = 0.
    """)

    st.markdown("""
    При этом погрешность формулы будет $$ O(h^2) $$:
    """)

    st.latex(r"""
        y_2'' = \frac{y_3 - y_1}{2h} + \frac{h^2}{6} y_2'''
    """)


# 4.1.2. Метод Рунге—Ромберга повышения точности
def runge_romberg_method_of_increasing_accuracy():
    st.header("""4.1.2. Метод Рунге—Ромберга повышения точности
    """)

    st.markdown("""
    Как следует из предыдущего рассмотрения, для вычисления производной с высокой точностью надо привлекать большее 
    число узлов, при этом получаются достаточно громоздкие формулы. Оказывается, что можно, зная порядок погрешности 
    простейших формул дифференцирования вида (3) для равноотстоящих узлов, получить значение производной с повышенной 
    точностью, не прибегая к громоздким формулам.
    """)

    st.latex(r"""
        y^{(k)}(x) = \varphi(x, h) + \psi(x) h^p + O(h^{p+1})\tag 7
    """)

    st.markdown("""
    где $$ p $$ характеризует порядок точности формулы дифференцирования.

    Вычислим ту же производную $$ y^{(k)}(x) $$ по формуле (7), но используя шаг $$ h_1 = r h $$:
    """)

    st.latex(r"""
        y^{(k)}(x) = \varphi(x, rh) + \psi(x)\cdot(rh)^p + O\left[(rh)^{p+1}\right]\tag{8}
    """)

    st.markdown("""
    Из формул (7) и (8) можно получить оценку погрешности формулы:
    """)

    st.latex(r"""
        R \equiv \psi(x) h^p = \frac{\varphi(x, h) - \varphi(x, rh)}{r^p - 1} + O(h^{p+1})\tag {9}
    """)

    st.markdown("""
    (первая формула Рунге). Теперь, зная оценку погрешности (9), можно получить уточненное значение производной:
    """)

    st.latex(r"""
        y^{(k)}(x) = \varphi(x, h) + \frac{\varphi(x, h) - \varphi(x, rh)}{r^p - 1} + O(h^{p+1})\tag {10}
    """)

    st.markdown("""
    (вторая формула Рунге). Рассмотрим примеры.
    """)

    st.markdown("""
    ### Пример 1.

    Пусть функция $$ y(x) = \lg x $$ задана таблицей:
    """)

    st.markdown("""
    | x  | 1  | 2  | 3   | 4   | 5   |
    |----|----|----|-----|-----|-----|
    | y  | 0  | 0.301  | 0.478  | 0.602  | 0.699  |

    И нужно вычислить $$ y'(3) $$.
    """)

    st.markdown("""
    Вычислим эту производную следующим образом:
    """)

    st.latex(r"""
        y'(3) \approx \frac{y(4) - y(2)}{4 - 2} = 0.151 \quad (h = 1);
    """)

    st.latex(r"""
        y'(3) \approx \frac{y(5) - y(1)}{5 - 1} = 0.175 \quad (h = 2).
    """)

    st.markdown("""
    Здесь $$ p = 2 $$, $$ r = 2 $$, поэтому уточненное значение есть:
    """)

    st.latex(r"""
        y'(3) = 0.151 + \frac{0.151 - 0.175}{2^2 - 1} = 0.143.
    """)

    st.markdown("""
    Точное значение $$ y'(3) = 0.145 $$.
    """)
    st.markdown("""
    ##### Пример реализации метода при помощи Python
    """)
    st.code("""
    # Табличные значения функции y(x) = lg(x)
    x_values = [1, 2, 3, 4, 5]
    y_values = [0, 0.301, 0.478, 0.602, 0.699]  # log10 values

    # Вычисление первой производной через конечные разности
    def finite_difference(x1, y1, x2, y2):
        return (y2 - y1) / (x2 - x1)

    # Первое приближение с шагом h = 1 (используем x = 2 и x = 4)
    h1 = 1
    y_prime_h1 = finite_difference(x_values[1], y_values[1], x_values[3], y_values[3])

    # Второе приближение с шагом h = 2 (используем x = 1 и x = 5)
    h2 = 2
    y_prime_h2 = finite_difference(x_values[0], y_values[0], x_values[4], y_values[4])

    # Параметры метода Рунге
    r = h2 / h1
    p = 2  # Порядок точности

    # Уточнение значения производной по методу Рунге
    y_prime_refined = y_prime_h1 + (y_prime_h1 - y_prime_h2) / (r ** p - 1)
    print(f"Производная методом конечных разностей при h = 1: {y_prime_h1:.5f}")
    print(f"Производная методом конечных разностей при h = 2: {y_prime_h2:.5f}")
    print(f"Уточнённая производная по методу Рунге: {y_prime_refined:.5f}")
    """)
    code_editor()

    st.markdown("""

    ### Пример 2.

    Пусть имеются равноотстоящие узлы $$ x_1, x_2, x_3, x_4 $$, причем $$ x_{i+1} - x_i = h $$, и пусть требуется
     вычислить $$ y'_{5/2} = y'(x_{5/2}) $$:
    """)

    st.latex(r"""
        y'_{5/2} = \frac{y_3 - y_2}{h}, \quad y'_{5/2} = \frac{y_4 - y_1}{3h}.
    """)

    st.markdown("""
    Здесь $$ p = 2 $$, $$ r = 3 $$, по второй формуле Рунге получим:
    """)

    st.latex(r"""
        y'_{5/2} = \frac{y_3 - y_2}{h} + \frac{1}{8} \left[ \frac{y_3 - y_2}{h} - \frac{y_4 - y_1}{3h} \right]
        = \frac{y_1 - 27y_2 + 27y_3 - y_4}{24h}
    """)

    st.markdown("""
    Точность этой формулы должна иметь порядок не ниже $$ O(h^3) $$, на самом деле она равна $$ O(h^4) $$.
    """)

    st.markdown("""
    Метод Рунге обходится для достаточно гладких функций на произвольное число сеток узлов. Пусть для некоторой 
    функции $$ Z(x) $$ получено приближенное значение $$ φ(x, h) $$ с использованием сетки узлов с шагом $$ h $$ 
    и известно, что погрешность можно представить в виде:
    """)

    st.latex(r"""
        Z(x) = \varphi(x, h) + \sum_{m \geq p} \psi_m(x) h^m \tag{11}
    """)

    st.markdown("""
    (этот вид устанавливается с помощью разложений $$ φ(x, h) $$ вблизи точки $$ x $$ в ряд Тейлора). Пусть теперь 
    проведены расчёты на $$ q $$ разных сетках с шагами $$ h_j $$, $$ j = 1, 2, ..., q $$. Считая, что в (11) $$ 
    \\psi_m(x) $$ не зависят от сеток, можем составить систему уравнений вида:
    """)

    st.latex(r"""
        Z(x) - \sum_{m = p}^{p+q-2} \psi_m(x) h_j^m = \varphi(x, h_j) + O(h_j^{p+q-1}) \quad (j = 1, 2, ..., q)
    """)

    st.markdown("""
    Решая её относительно $$ Z(x) $$ и {$$ \\psi_m(x) $$}, получим для $$ Z(x) $$ формулу Ромберга.
    """)

    st.markdown("""
    ### Замечание 1.
    Метод Рунге-Ромберга можно применять только в том случае, если $$ \\psi_m(x) $$ одинаковы для всех сеток. Обычно 
    так бывает, если расположение узлов относительно $$ x $$ подобно для всех сеток. Если этого нет, то метод 
    неприменим. Обычно при его использовании прибегают к изменению шага для узлов вдвое.
    """)

    st.markdown("""
    ### Замечание 2.
    Очевидно, что погрешность формул численного дифференцирования тем меньше, чем меньше шаг $$ h $$; с другой стороны, 
    при малых шагах $$ h $$ мы вынуждены вычитать близкие числа, т.е. происходит потеря точности. Поэтому, если значения
    функции имеют невысокую точность (зашумлены), то для вычисления производных лучше не использовать конечные
    разности, а предварительно получить аппроксимирующую функцию с помощью МНК.
    """)


# 4.2.2.
def free_nodes_gaussian_quadratures():
    st.header("""4.2.2. Свободные узлы (квадратуры Гаусса)
        """)
    st.markdown("""
    Рассмотрим теперь квадратурные формулы, у которых свободны не только веса, но и узлы:
    """)

    st.latex(r"""
    \int_{\alpha}^{\beta} \rho(x) y(x) dx = W_1 y(x_1) + \dots + W_n y(x_n) + R, \quad \rho(x) > 0.\tag {24}
    """)

    st.markdown("""
    В этом случае у нас $$2n$$ параметров, и можно попытаться сделать формулу точной для $$y(x) = 1, x, 
    \\dots, x^{2n-1}$$. Покажем, как в этом случае можно получить узлы и веса. Будем считать, что функция 
    $$\\rho(x) > 0$$ и непрерывна на $$(\\alpha, \\beta)$$, и интеграл
    """)

    st.latex(r"""
    \int_{\alpha}^{\beta} \rho(x) dx
    """)

    st.markdown("""
    существует. Известно, что при выполнении этих условий существует полная система многочленов $$P_m(x)$$, 
    ортогональных на $$(\\alpha, \\beta)$$ с весом $$\\rho(x)$$:
    """)

    st.latex(r"""
    \int_{\alpha}^{\beta} \rho P_k(x) P_m(x) dx = \delta_{km} \int_{\alpha}^{\beta} \rho P_k^2(x) dx.\tag {25}
    """)

    st.markdown("""
    При этом все нули этих многочленов действительны и лежат на $$(\\alpha, \\beta)$$. Пусть $$x_1, 
    \\dots, x_n$$ — искомые узлы. Рассмотрим многочлен:
    """)

    st.latex(r"""
    \pi_n(x) = \prod_{k=1}^n (x - x_k).
    """)

    st.markdown("""
    Функция $$f(x) = \\pi_n(x) P_m(x)$$ при $$m \\leq n - 1$$ будет многочленом степени не выше $$2n - 1$$. Поэтому для 
    нее формула будет точной:
    """)

    st.latex(r"""
    \int_{\alpha}^{\beta} \rho \pi_n P_m(x) dx = \sum_{k=1}^n W_k \pi_n(x_k) P_m(x_k) = 0,
    """)

    st.markdown("""
    так как $$\\pi_n(x_k) = 0$$. Следовательно, многочлен $$\\pi_n(x)$$ ортогонален всем многочленам 
    $$P_m(x),\\ m \\leq n - 1$$. Представим $$\\pi_n(x)$$ в виде:
    """)

    st.latex(r"""
    \pi_n(x) = \sum_{k=0}^n b_k P_k(x).
    """)

    st.markdown("""
    Тогда:
    """)

    st.latex(r"""
    b_k \int_{\alpha}^{\beta} \rho P_k^2(x) dx = \int_{\alpha}^{\beta} \rho \pi_n(x) P_k(x) dx = 0, \quad k \leq n - 1.
    """)

    st.markdown("""
    Таким образом, $$\\pi_n(x)$$ с точностью до множителя совпадает с $$P_n(x)$$. Следовательно, узлы квадратур Гаусса 
    $$(\\rho(x)\\equiv 1)$$
    или Гаусса–Кристоффеля $$(\\rho(x)\\ne 1)$$ являются нулями соответствующего многочлена $$P_n(x)$$ из системы 
    многочленов, ортогональных на $$(\\alpha, \\beta)$$ с весом $$\\rho(x)$$.

    Пусть узлы $$x_1, \\dots, x_n$$ найдены. Тогда веса можно определить методом моментов, как разобрано выше,
     либо поступить следующим образом. Составим многочлен вида:
    """)

    st.latex(r"""
    L_m(x) = \prod_{k=1, k \neq m}^n \frac{x - x_k}{x_m - x_k},
    """)

    st.markdown("""
    (это те же самые многочлены, которые фигурируют в методе интерполяции по Лагранжу). Степень их равна $$n - 1$$, 
    следовательно, формула будет точной для каждого $$L_m$$ точка
    """)

    st.latex(r"""
    \int_{\alpha}^{\beta} \rho(x) L_m(x) dx =W_1L_m(x_1)+\ldots+W_mL_m(x_m)+\ldots+W_nL_m(x_n) = W_m.
    """)

    st.markdown("""
    Если в формулу (24) подставить многочлен $$L_m^2(x)$$, который имеет степень $$2n - 2$$ и для которого $$(24)$$ тоже 
    верна, то получим
    """)

    st.latex(r"""
    W_m = \int_{\alpha}^{\beta} \rho L_m^2(x) dx > 0.
    """)

    st.markdown("""
    Таким образом, все веса формулы Гаусса (или Гаусса–Кристоффеля) положительны. При этом имеем, полагая $$y(x) = 1$$ 
    в  $$(24)$$,
    """)

    st.latex(r"""
    \sum_{k=1}^n W_k = \int_{\alpha}^{\beta} \rho(x) dx,
    """)

    st.markdown("""
    т. е. все веса равномерно ограничены. Положительность и ограниченность весов означает, что ошибки в вычисленных 
    значениях $$y_i$$ не дают нарастающего неограниченного вклада в интеграл с ростом $$n$$.

    Формулы Гаусса–Кристоффеля называются **формулами наивысшей алгебраической точности**. Частные случаи квадратурных 
    формул Гаусса–Кристоффеля можно получить при использовании классических ортогональных многочленов Лежандра, 
    Чебышева, Лагерра, Эрмита. Имеются таблицы узлов и весов этих квадратурных формул.
    
    Так как эти многочлены задаются на определенных интервалах $$[\\alpha, \\beta]$$, то в случае произвольного 
    интервала требуется предварительное преобразование интеграла.


    ### Пример 1

    Пусть $$\\rho(x) \\equiv 1$$ и надо вычислить
    """)

    st.latex(r"""
    \int_{\alpha}^{\beta} y dx.
    """)

    st.markdown("""
    Чтобы построить квадратурную формулу Гаусса, преобразуем интервал $$(\\alpha, \\beta)$$ в $$[-1, 1]$$, на котором 
    ортогональны полиномы Лежандра. Для этого сделаем замену переменной:
    """)

    st.latex(r"""
    x = \frac{\beta - \alpha}{2} t + \frac{\beta + \alpha}{2}, \quad -1 \leq t \leq 1.
    """)

    st.markdown("""
    Тогда
    """)

    st.latex(r"""
    \int_{\alpha}^{\beta} y dx = \frac{\beta - \alpha}{2} \int_{-1}^{1} \tilde{y} dt.
    """)

    st.markdown("""
    Пусть $$t_1, \\dots, t_n$$ — нули многочлена Лежандра $$P_n(t)$$, $$\\tilde{W}_1,\\ldots,\\tilde{W}_n$$ — 
    соответствующие веса (для $$[-1, 1]$$), тогда
    """)

    st.latex(r"""
    \int_{\alpha}^{\beta} y dx = \frac{\beta - \alpha}{2} \sum_{k=1}^n \tilde{W}_k \tilde {y}(t_k)=
    \sum_{k=1}^n \tilde{W}_k y(x_k),
    """)

    st.markdown("""
    где
    """)

    st.latex(r"""
    W_k = \frac{\beta - \alpha}{2} \tilde{W}_k, \quad x_k = \frac{\beta - \alpha}{2} t_k + \frac{\beta + \alpha}{2}.
    """)

    st.markdown("""
    ### Пример 2 
    
    Пусть требуется вычислить
    """)

    st.latex(r"""
    E(x) = \int_x^{\infty} \frac{e^{-t}}{t} \, dt.
    """)

    st.markdown("""
    Положим $$t - x = U$$, тогда $$t = U + x$$ и
    """)

    st.latex(r"""
    E(x) = \int_x^{\infty} \frac{e^{-(U+x)}}{U + x} \, dU = e^{-x} \int_0^{\infty} \frac{e^{-U}}{U + x} \, dU.
    """)

    st.markdown("""
    Полагая здесь $$\\rho(U) = e^{-U}$$, можно записать
    """)

    st.latex(r"""
    E(x) = e^{-x} \sum_{k=1}^{n} \frac{W_k}{x + x_k},
    """)

    st.markdown("""
    где $$x_k, W_k$$ — нули полинома Лагерра $$L_n(x)$$ и соответствующие веса квадратурных формул.
    """)

    st.markdown("""
    ### Пример 3

    Пусть требуется вычислить
    """)

    st.latex(r"""
    \int_{\alpha}^{\beta} y(x) dx.
    """)

    st.markdown("""
    Сделаем замену
    """)

    st.latex(r"""
    x = (\beta - \alpha)t + \alpha, \quad 0 \leq t \leq 1, \quad \int_{\alpha}^{\beta} y dx = 
    (\beta - \alpha) \int_{0}^{1} \tilde{y} dt.
    """)

    st.markdown("""
    Ранее (см. раздел 3.4.4, пример 1) мы нашли три ортогональных с весом $$\\rho = 1$$ на отрезке $$[0,1]$$ полинома:
    """)

    st.latex(r"""
    P_0 = 1; \quad P_1 = t - \frac{1}{2}; \quad P_2 = t^2 - t + \frac{1}{6}.
    """)

    st.markdown("""
    Построим с помощью $$P_2$$ квадратурную формулу Гаусса
    """)

    st.latex(r"""
    P_2(t) = 0 \Rightarrow t_1 = \frac{3 - \sqrt{3}}{6}; \quad t_2 = \frac{3 + \sqrt{3}}{6}.
    """)

    st.markdown("""
    Составим многочлены Лагранжа
    """)

    st.latex(r"""
    L_1 = \frac{t - t_2}{t_1 - t_2}; \quad L_2 = \frac{t - t_1}{t_2 - t_1}
    """)

    st.markdown("""
    и найдем веса
    """)

    st.latex(r"""
    \tilde{W_1} = \int_0^1 L_1 \, dt = 1/2; \quad \tilde{W_2} = \int_0^1 L_2 \, dt = 1/2.
    """)

    st.markdown("""
    Возвращаясь к переменной $$x$$, находим
    """)

    st.latex(r"""
    \int_{\alpha}^{\beta} y \, dx = \frac{\beta - \alpha}{2} \left[ y\left(\alpha + \frac{3 - \sqrt{3}}{6} (\beta - 
    \alpha)\right) + y\left(\alpha + \frac{3 + \sqrt{3}}{6} (\beta - \alpha)\right)\right].
    """)

    st.markdown("""
    Эта формула будет точной для $$y(x) = 1, x, x^2, x^3$$, как и формула Эйлера $$(23)$$   .
    """)


# 4.2.3. Оценка остаточного члена
def evaluation_of_the_residual_member():
    st.header("""
    4.2.3. Оценка остаточного члена
    """)

    st.markdown("""
    Оценку остаточного члена квадратурной формулы, чаще всего, получают, исходя из разложения функции на отрезке 
    $$[a, b]$$ в ряд Тейлора. Пусть для вычисления интеграла использована некоторая квадратурная формула
    """)

    st.latex(r"""
    \int_\alpha^\beta \rho y(x) dx = \sum_{i=1}^n W_i y_i + R, \quad y_i = y(x_i), \quad x_i, 
    \dots, x_n \in [\alpha, \beta],
    """)
    st.markdown("""
        которая является точной для многочленов степени $$\\leq m$$.
        
        Раскладывая функцию $$y(x)$$ в ряд Тейлора на отрезке $$[\\alpha, \\beta]$$ относительно некоторой точки $$x_0$$
        (обычно $$x_0=(\\alpha-\\beta)/2$$), находим
        """)

    st.latex(r"""
    y(x) = y_0 + (x - x_0) y_0' + \frac{(x - x_0)^2}{2} y_0'' + \dots + \frac{(x - x_0)^m}{m!} y_0^{(m)} + \frac{(x - 
    x_0)^{m+1}}{(m+1)!} y_0^{(m+1)} + \dots,
    """)

    st.markdown("""
    где
    """)

    st.latex(r"""
    y_0 = y(x_0); \quad y_0' = \left. \frac{dy}{dx} \right| \scriptsize{x=x_0}\normalsize; \quad y_0'' = \left. 
    \frac{d^2 y}{dx^2} \right| \scriptsize{x=x_0}
    """)

    st.markdown("""
    и т. д. Аналогичные разложения выполняются для каждого $$y_i$$, входящего в правую часть $$(24)$$,
    """)

    st.latex(r"""
    y_i = y_0 + (x_i - x_0) y_0' + \dots
    """)

    st.markdown("""
    Тогда остаточный член $$R$$ будет иметь вид
    """)

    st.latex(r"""
    R = \int_\alpha^\beta \rho y \, dx - \sum_{i=1}^n W_i y_i = \int_\alpha^\beta \rho \left[  y_0 + \sum_{j=1}^\infty 
    \frac{(x - x_0)^j}{j!} y_0^{(j)} \right] dx - \sum_{i=1}^n W_i \left[ y_0 + \sum_{j=1}^\infty 
    \frac{(x_i - x_0)^j}{j!} y_0^{(j)} \right].
    """)

    st.markdown("""
    Обычно в качестве остаточного члена берут первое не исчезающее слагаемое в правой части.
    """)

    st.markdown("""
    Рассмотрим некоторые частные формулы для интегрирования.
    """)

    st.markdown("""
    Пусть $$\\rho(x) = 1$$ и
    """)

    st.latex(r"""
    \int_\alpha^\beta y \, dx \approx \frac{\beta - \alpha}{2} \left[ y(\alpha) + y(\beta) \right]
    """)

    st.markdown("""
    (формула трапеции). Положим
    """)

    st.latex(r"""
    x_0 = \frac{\alpha + \beta}{2};
    """)

    st.latex(r"""
    y(x) = y_0 + (x - x_0) y_0' + \frac{(x - x_0)^2}{2} y_0'' + \dots
    """)

    st.markdown("Для $$R$$ находим")

    st.latex(r"""
    R = \int_\alpha^\beta \left[ y_0 + (x - x_0) y_0' + \frac{(x - x_0)^2}{2} y_0'' + \dots \right] dx -
    
    """)

    st.latex(r"""
    - \frac{\beta - \alpha}{2} \left[ y_0 + (\alpha - x_0) y_0' + \frac{(\alpha - x_0)^2}{2}y_0'' +
    \dots y_0 + (\beta - x_0) y_0' + \frac{(\beta - x_0)^2}{2}y_0'' +\dots\right]
    """)
    st.latex(r"""
    = y_0'' (\beta - \alpha)^2 \left[ \frac{1}{6} (\beta - x_0)^2 + \frac{1}{6} (\beta - x_0)(\alpha - x_0)  +\right.
    
    """)

    st.latex(r"""
    \left. + \frac{1}{6} (\alpha - x_0)^2 - \frac{1}{4} (\alpha - x_0)^2 - \frac{1}{4} (\beta - x_0)^2+ \dots \right].
    """)
    st.markdown("В силу выбора $$x_0$$")

    st.latex(r"""
    \alpha - x_0 = -\frac{\beta - \alpha}{2}; \quad \beta - x_0 = \frac{\beta - \alpha}{2}
    """)

    st.markdown("Поэтому")

    st.latex(r"""
    R = y_0'' (\beta - \alpha)^3 \left[ \frac{1}{24} - \frac{1}{24} + \frac{1}{24} - \frac{1}{16} - \frac{1}{16} 
    \right] = -\frac{(\beta - \alpha)^3}{12} y_0''
    """)

    st.markdown("Аналогично можно получить остаточные члены для других квадратурных формул.")
    st.markdown("**Формула центральных прямоугольников:**")

    st.latex(r"""
    R = -\frac{1}{24} (\beta - \alpha)^3 y_0''
    """)

    st.markdown("""
    Отметим, что, комбинируя формулы трапеции и прямоугольников, мы получим погашение остаточных членов и придем
    к формуле Симпсона.
    """)
    st.markdown("**Формула Симпсона:**")

    st.latex(r"""
    R = -\frac{1}{90} \left( \frac{\beta - \alpha}{2} \right)^5 y_0^{(4)}
    """)

    st.markdown("""
    Напомним, что эта формула строилась как точная для $$y(x) = 1, x, x^2$$; из оценки $$R$$ видно, что она 
    будет точной и для $$y = x^3$$.
    """)
    st.markdown("**Формула Эйлера:**")

    st.latex(r"""
    R = \frac{1}{720} (\beta - \alpha)^5 y_0^{(4)}
    """)

    st.markdown("""
    Из полученных оценок следует, что если отрезок $$[\\alpha, \\beta]$$ не мал, то остаточный член квадратурной
    формулы может оказаться большим.
    """)

    st.markdown("""
    Поэтому для повышения точности отрезок $$[\\alpha, \\beta]$$ надо по возможности выбирать таким образом, 
    чтобы остаточный член $$R$$ был меньше наперед заданной погрешности. Напомним, что в начале раздела (формула 
    $$(13)$$) исходный интеграл был заменен на сумму
    """)

    st.latex(r"""
    F = \int_a^b \rho y \, dx = \sum_{m=1}^M \int_{a_m}^{a_{m+1}} \rho y \, dx,\tag {25}
    """)

    st.markdown("""
    где $$a = a_1 < a_2 < \\dots < a_{M+1} = b$$, и найдены квадратурные формулы и погрешность для каждого отрезка
    $$[a_m, a_{m+1}]$$. Поэтому, если в формуле (25) каждый интеграл в сумме заменить на квадратурную формулу, 
    то получим **обобщенную квадратурную формулу** (трапеций, Симпсона и т. д.). Часто всего отрезки 
    $$[a_m, a_{m+1}]$$ выбирают равной длины $$h = (b - a) / M$$.
    """)

    st.markdown("Напишем для этого случая соответствующие частные обобщенные формулы ($$\\rho(x) = 1$$).")

    st.markdown("**Формула трапеций:**")

    st.latex(r"""
    \int_a^b y \, dx = \frac{1}{2} h \sum_{m=1}^M (y_m + y_{m+1})- \frac{h^3}{12} \sum_{m=1}^M y_{m+1/2}'' \approx
    """)

    st.latex(r"""
    \approx h \left[ \frac{1}{2} y_1 + y_2 + \dots + y_M + \frac{1}{2} y_{M+1} \right] - 
    \frac{h^2}{12} \int_a^b y'' \, dx.\tag{26}
    """)

    st.markdown("Здесь")

    st.latex(r"""
    y''_{m+1/2} = y'' \left( \frac{a_m + a_{m+1}}{2} \right); \quad h \sum_{m=1}^M y''_{m+1/2} \approx \int_a^b y'' \, 
    dx.
    """)

    st.markdown("Главный член погрешности есть")

    st.latex(r"""
    \frac{h^2}{12} \int_a^b y'' \, dx,
    """)

    st.markdown("т. е. формула трапеций имеет 2-й порядок точности.")

    st.markdown("**Формула центральных прямоугольников:**")

    st.latex(r"""
    \int_a^b y \, dx = h \sum_{m=1}^M y_{m+1/2} + \frac{h^3}{24} \sum_{m=1}^M y''_{m+1/2} \approx 
    """)

    st.latex(r"""
    \approx h \left[ y_{3/2} + \dots + y_{M+1/2} \right] + \frac{h^2}{24} \int_a^b y'' \, dx.\tag{27}
    """)

    st.markdown("**Формула Симпсона ($$M$$ — четное):**")

    st.latex(r"""
    \int_a^b y \, dx = \frac{h}{3} \sum_{m=1}^{M/2} \left( y_{2m-1} + 4 y_{2m} + y_{2m+1} \right) - \frac{1}{90} h^5 
    \sum_{m=1}^{M/2} y_{2m}^{(4)} \approx
    """)

    st.latex(r"""
    \approx \frac{h}{3} \left[ y_1 + 4 y_2 + 2 y_3 + 4 y_4 + \dots + 4 y_{M} + y_{M+1} \right] - \frac{h^4}{180} 
    \int_a^b y^{(4)} \, dx \tag {27}
    """)

    st.markdown("поскольку")

    st.latex(r"""
    \frac{1}{90} h^5 \sum_{m=1}^{M/2} y_{2m}^{(4)} = \frac{1}{180} h^42h \sum_{m=1}^{M/2} y_{2m}^{(4)} \approx
    \frac{h^4}{180} \int_a^b y^{(4)} \, dx.
    """)


# 4.2.4. Повышение точности квадратурных формул
def numerical_integration_improving_the_accuracy_of_quadrature_formulas():
    st.header("4.2.4. Повышение точности квадратурных формул")

    st.markdown("""
    Если порядок остаточного члена квадратурной формулы известен, то к ней можно применить метод Рунге для повышения 
    точности вычислений.
    """)

    st.markdown("""
    Пусть, например, вычисляется интеграл по формуле трапеций с шагом $$ h $$ (число узлов предполагается нечётным):
    """)

    st.latex(r"""
    \int_a^b y \, dx \approx F_1 - \frac{h^2}{12} \int_a^b y'' \, dx,
    """)

    st.markdown("где")

    st.latex(r"""
    F_1 = h \left[ \frac{1}{2}y_1 + y_2 + \dots + \frac{1}{2}y_{2M+1} \right].
    """)

    st.markdown("""
    Вычислим теперь тот же интеграл с шагом $$ 2h $$:
    """)

    st.latex(r"""
    \int_a^b y \, dx \approx F_2 - \frac{h^2}{3} \int_a^b y'' \, dx,
    """)

    st.markdown("где")

    st.latex(r"""
    F_2 = 2h \left[ \frac{1}{2}y_1 + y_3 + \dots + \frac{1}{2}y_{2M+1} \right].
    """)

    st.markdown("""
    Отсюда имеем, исключая остаточные члены:
    """)

    st.latex(r"""
    3\int_a^b y \, dx \approx {4F_1 - F_2}.
    """)

    st.markdown("""
    Или:
    """)

    st.latex(r"""
    \int_a^b y \, dx \approx \frac{h}{3} \left[ y_1 + 4y_2 + 2y_3 + \dots + y_{2M+1} \right].
    """)

    st.markdown("""
    Таким образом, мы получили обобщённую формулу Симпсона!
    """)

    st.markdown("""
    Так обстоит дело, если порядок точности остаточного члена известен. Пусть теперь этот порядок точности $$ p $$ 
    существует, но неизвестен. В этом случае также можно проводить уточнение результата, если вычисления проведены с 
    тремя или более шагами (процесс Эйткена).
    """)

    st.markdown("""
    Пусть расчёты проведены с шагами $$ h_1 = h $$, $$ h_2 = qh $$, $$ h_3 = q^2h $$ и получены значения интегралов $$ 
    F_1, F_2, F_3 $$. Тогда значение интеграла $$ F $$ равно (если ограничиться главным членом погрешности):
    """)

    st.latex(r"""
    F = F_k + \alpha h_k^p, \quad k = 1, 2, 3.
    """)

    st.markdown("""
    Из этих уравнений можно определить $$ F $$, $$ \\alpha $$, $$ p $$. Положим $$ \\beta = ah^p $$, 
    $$ \\gamma = q^p $$.  
    Тогда получим:
    """)

    st.latex(r"""
    F - F_1 = \beta , \quad F - F_2 = \beta \gamma, \quad F - F_3 = \beta \gamma^2.
    """)

    st.markdown("""
    Умножив первое уравнение на третье и исключив с помощью второго $$ \\beta^2 \\gamma^2 $$, найдём:
    """)

    st.latex(r"""
    (F - F_1)(F - F_3) = (F - F_2)^2.
    """)

    st.markdown("Откуда:")

    st.latex(r"""
    F = F_1 + \frac{(F_1 - F_2)^2}{2F_2 - F_1 - F_3} = \frac{F_1F_3 - F_2^2}{ F_1 - 2F_2  + F_3}.
    """)

    st.markdown("""
    Вычитая одно уравнение из другого, получим:
    """)

    st.latex(r"""
    F_2 - F_1 = \beta (1 - \gamma), \quad F_3 - F_2 = \beta \gamma (1 - \gamma).
    """)

    st.markdown("Отсюда:")

    st.latex(r"""
    \gamma = q^p = \frac{F_3 - F_2}{F_2 - F_1}.
    """)

    st.markdown("""
    Следовательно, порядок точности квадратурной формулы:
    """)

    st.latex(r"""
    p = \ln \left( \frac{F_3 - F_2}{F_2 - F_1} \right) / \ln q.
    """)

    st.markdown("""**Пример. Рассмотрим интеграл:**""")

    st.latex(r"""
    F = \int_0^1 \sqrt{x} \, dx = \frac{2}{3}.
    """)

    st.markdown("""
    Здесь $$ y(x) = \\sqrt{x} $$ имеет при $$ x \\to 0 $$ неограниченную производную. Следовательно, получить оценку 
    погрешности, используя разложение в ряд, нельзя. Составим таблицу значений функции:
    """)

    st.markdown("""
        |$$x$$|    0 | 0,25   | 0,50   | 0,75   | 1,0    |
        |-----|--------|--------|--------|--------|--------|
        |$$y$$| 0,00000 | 0,5000 | 0,7071 | 0,8660 | 1,0000 |
    """)

    st.markdown("""
        Рассмотрим результаты интегрирования с использованием этой таблицы:
        """)

    st.markdown("""
        | $$ h $$  | Формула трапеций | Формула Симпсона | Формула Эйткена |
        |----------|------------------|------------------|-----------------|
        | 1,00     | 0,5000           | –                | –               |
        | 0,50     | 0,6036           | 0,6381           | –               |
        | 0,25     | 0,6433           | 0,6565           | 0,6680          |
        """)

    st.markdown("""
        Видно, что уточнение первого столбца методом Эйткена дает хороший результат. Вычислим порядок $$ p $$ формулы 
        трапеций для этой функции:
        """)

    st.latex(r"""
        p = \frac{\ln \left( \frac{0.6433 - 0.6036}{0.6036 - 0.5000} \right)}{\ln 0.5} \approx 1.38.
        """)

    st.markdown("""
        Т.е. порядок – дробное число! Это – обычный факт для квадратурных формул, применяемых к функциям с особенностью,
         которые явно её не учитывают. Если особенности нет, то теоретический порядок должен быть при $$ h \\to 0 $$ 
         близким к вычисленному.
        """)

    st.code("""
    import math

    def calculate_integral_trapezoid(y_values, h):
        # Вычисляет интеграл по формуле трапеций.
        n = len(y_values)
        integral = y_values[0] + y_values[-1]
        for i in range(1, n - 1):
            integral += 2 * y_values[i]
        return (h / 2) * integral
    
    def aitken_extrapolation(F1, F2, F3):
        # Применяет метод Эйткена для уточнения результата.
        numerator = (F1 - F2) ** 2
        denominator = 2 * F2 - F1 - F3
        return F1 + numerator / denominator
    
    def calculate_order_of_accuracy(F1, F2, F3, q):
        # Вычисляет порядок точности квадратурной формулы.
        ratio = abs(F3 - F2) / abs(F2 - F1)
        if ratio <= 0:
            raise ValueError("Отношение ratio должно быть положительным для вычисления логарифма.")
        return -math.log(ratio) / math.log(q)
    
    # Табличные значения функции y(x) = sqrt(x)
    y_values_full = [0.0, 0.5, 0.7071, 0.8660, 1.0]  # Значения функции y(x)
    h_values = [1.0, 0.5, 0.25]  # Шаги интегрирования
    subset_indices = {
        1.0: [0, 4],        # Узлы для h=1.0
        0.5: [0, 2, 4],     # Узлы для h=0.5
        0.25: [0, 1, 2, 3, 4]  # Узлы для h=0.25
    }
    
    # Вычисляем интегралы с разными шагами
    F_values = []
    for h in h_values:
        indices = subset_indices[h]
        y_subset = [y_values_full[i] for i in indices]
        F_values.append(calculate_integral_trapezoid(y_subset, h))
    
    # Применяем метод Эйткена
    F_aitken = aitken_extrapolation(F_values[0], F_values[1], F_values[2])
    
    # Вычисляем порядок точности
    try:
        p = calculate_order_of_accuracy(F_values[0], F_values[1], F_values[2], q=2)
    except ValueError as e:
        p = "Ошибка: " + str(e)
        
        
    # Вывод результатов
    print("Результаты интегрирования:")
    print(f"Формула трапеций (h=1.0): {F_values[0]:.4f}")
    print(f"Формула трапеций (h=0.5): {F_values[1]:.4f}")
    print(f"Формула трапеций (h=0.25): {F_values[2]:.4f}")
    print(f"Метод Эйткена: {F_aitken:.4f}")
    print(f"Порядок точности p: {p}")


    """)

    code_editor()


# 4.2.5. Нестандартные формулы
def numerical_integration_irregular_functions():
    st.header("""4.2.5. Нестандартные формулы""")

    st.markdown("""
    Стандартные квадратурные формулы можно применять при интегрировании функций без особенностей. Если же 
    подынтегральная функция имеет какие-либо особенности, их надо учесть при построении квадратурных формул.
    """)


# 4.2.5.1. Разрывные функции
def numerical_integration_discontinuous_functions_integration():
    st.header("4.2.5.1. Разрывные функции")

    st.markdown("""
    Пусть подынтегральная функция и её производные кусочно-непрерывны. Разобьём отрезок $$ [a, b] $$ интегрирования так, 
    чтобы на отдельных отрезках функция и её производные до $$ p $$-порядка были непрерывны, и представим исходный 
    интеграл в виде:
    """)

    st.latex(r"""
        \int_a^b y \, dx = \sum_{m=1}^M \int_{a_m}^{a_{m+1}} y \, dx, \quad a_1 = a, \quad a_{m+1} = b.
    """)

    st.markdown("""
    К каждому интегралу по отрезку $$ [a_m, a_{m+1}] $$ можно применить квадратурную формулу порядка $$ q \\leq p $$.
    Если разрывы не выделять, то точность вычислений будет небольшая и будет медленно нарастать с уменьшением шага 
    интегрирования.
    """)


# 4.2.5.2. Нелинейные формулы
def numerical_integration_nonlinear_formulas():
    st.header("4.2.5.2. Нелинейные формулы")

    st.markdown("""
    Иногда удаётся при построении квадратурных формул использовать явно характер изменения подынтегральной функции. 
    Например, вычисляется:
    """)

    st.latex(r"""
        \int_a^b y \, dx = \sum_{m=1}^M \int_{a_m}^{a_{m+1}} y \, dx,
    """)

    st.markdown("""
    и известно, что в каждом интервале $$ (a_m, a_{m+1}) $$ $$ y(x) \\equiv \\alpha_m e^{\\beta_m x} $$, 
    воспользуемся этим обстоятельством для вычисления интеграла.

    Пусть $$ a_m \\leq x \\leq a_{m+1} $$, тогда для $$ \\alpha_m, \\beta_m $$ найдём:
    """)

    st.latex(r"""
        y_m = \alpha_m \exp(\beta_m a_m), \quad y_{m+1} = \alpha_m \exp(\beta_m a_{m+1}),
    """)

    st.markdown("откуда:")

    st.latex(r"""
        \beta_m = \ln(y_{m+1} / y_m) / (a_{m+1} - a_m)
    """)

    st.markdown("и")

    st.latex(r"""
        y(x) \equiv y_m \exp[\beta_m (x - a_m)].
    """)

    st.markdown("Поэтому:")

    st.latex(r"""
        \int_a^b y \, dx = \sum_{m=1}^M \int_{a_m}^{a_{m+1}} y \, dx = \sum_{m=1}^M (a_{m+1} - a_m)(y_m + y_{m+1}) / 
        \ln(y_{m+1} / y_m).
    """)

    st.markdown("""
    Формулы такого типа напоминают формулу трапеций. Нелинейные формулы высокого порядка редко употребляют, так как их 
    сложно строить. 
    Обычно используют формулы типа средних или трапеций и проводят вычисления на сужающихся сетках узлов с уточнением 
    результата методом Эйткена.
    """)


# 4.2.5.3. Метод Филона
def numerical_integration_philon_method():
    st.header("4.2.5.3. Метод Филона")

    st.markdown("""
    При решении радиотехнических задач часто встречается необходимость вычислить интегралы вида:
    """)

    st.latex(r"""
        F = \int_a^b y(x) e^{i \omega x} \, dx,
    """)

    st.markdown("""
    где $$ \\omega (b - a) \\gg 1 $$, а $$ f(x) $$ — медленно меняющаяся функция.

    Очевидно:
    """)

    st.latex(r"""
        y^{(p)}(x) \approx \omega^p,
    """)

    st.markdown("""
    и при больших $$ \\omega $$ эти производные велики, т.е. при интегрировании по стандартным формулам надо выбирать 
    шаг $$ h $$ в квадратурных формулах из условия $$ \\omega h \\ll 1 $$. Метод Филона основан на представлении $$ 
    f(x) $$ на отдельных отрезках в виде полинома и последующем аналитическом интегрировании. Положим, например:
    """)

    st.latex(r"""
            F = \int_a^b y \, dx = \sum_{m=1}^M \int_{a_m}^{a_{m+1}} y(x) \, dx 
            = \sum_{m=1}^M \left\{ f_{m+1/2} \int_{a_m}^{a_{m+1}} e^{i \omega x} \, dx 
            + \int_{a_m}^{a_{m+1}} r(x) e^{i \omega x} \, dx \right\}.
        """)

    st.markdown("Здесь:")

    # Вторая формула
    st.latex(r"""
            a_1 = a; \quad a_{M+1} = b; \quad f_{m+1/2} = f \left( \frac{a_m + a_{m+1}}{2} \right) = f(a_{m+1/2});
        """)

    # Третья формула
    st.latex(r"""
            r(x) = f(x) - f_{m+1/2} \equiv (x - a_{m+1/2}) f'_{m+1/2}.
        """)

    st.markdown("Следовательно, квадратурная формула средних имеет вид:")

    st.latex(r"""
        F = \frac{2}{\omega} \sum_{m=1}^M y_{m+1/2} \sin \frac{\omega h_m}{2}, \quad h_m = a_{m+1} - a_m. \tag{29}
    """)

    st.markdown("Погрешность для неё равна:")

    # Формула для погрешности
    st.latex(r"""
            R = \sum_{m=1}^M \int_{a_m}^{a_{m+1}} r e^{i \omega x} \, dx \approx \sum_{m=1}^M f'_{m+1/2} 
            \int_{a_m}^{a_{m+1}} (x - a_{m+1/2}) e^{i \omega x} \, dx =
        """)

    st.latex(r"""
            = \frac{2i}{\omega} \sum_{m=1}^M f'_{m+1/2} \left(\sin\frac{\omega h_m}{2} - 
            \frac{\omega h_m}{2} \cos\frac{\omega h_m}{2}\right) e^{i \omega a_{m+1/2}}. \tag{30}
        """)

    st.markdown("""
    Из формулы (30) следует, что при $$ \\omega h_m \\geq 1 $$ погрешность не имеет степенного характера, 
    поэтому нельзя применять 
    метод Рунге для уточнения результата.

    Для получения большей точности прибегают к более точной аппроксимации $$ f(x) $$ на отрезках $$ [a_m, a_{m+1}] $$.
    Получающиеся формулы будут настолько точны, насколько хорошо выбрана эта аппроксимация.
    """)


# 4.2.5.4. Несобственные интегралы
def numerical_integration_improper_integrals():
    st.header("4.2.5.4. Несобственные интегралы")

    st.markdown("""
    Рассмотрим сначала случай интегралов с бесконечными пределами. Здесь могут быть использованы различные приёмы для 
    вычисления.

    **Приём 1** – замена переменных, приводящая к конечным пределам.

    **Пример.** Пусть имеется интеграл:
    """)

    st.latex(r"""
        F = \int_a^\infty y(x) \, dx, \quad a > 0.
    """)

    st.markdown("""
    Положим:
    """)

    st.latex(r"""
        x = \frac{a}{1 - t}, \quad dx = \frac{a}{(1 - t)^2} \, dt,
    """)

    st.markdown("тогда:")

    st.latex(r"""
        F = \int_0^1 \bar{y}(t) \frac{a}{(1 - t)^2} \, dt,
    """)

    st.markdown("""
    и мы получили интеграл с конечными пределами. Если у подынтегральной функции не будет особенностей, 
    то можно использовать стандартные формулы.
    """)

    st.markdown("""
    **Приём 2** – обрезание бесконечного предела таким образом, чтобы интеграл по отбрасываемому интервалу 
    был меньше заданной ошибки вычисления.
    """)

    st.markdown("""
    **Приём 3** – использование формул Гаусса–Кристоффеля для бесконечного интеграла.
    """)

    st.markdown("""
    **Приём 4** – построение нелинейных квадратурных формул. Пусть теперь пределы интегрирования конечны, 
    но подынтегральная функция имеет особенность.

    **Приём 1** – аддитивное выделение особенности:
    """)

    st.latex(r"""
        F = \int_a^b y(x) \, dx = \int_a^b \varphi(x) \, dx + \int_a^b \psi(x) \, dx.
    """)

    st.markdown("""
    Здесь $$ φ(x), \\, \\psi(x) $$ выбраны так, что $$ φ(x) $$ — ограниченная функция, а $$ \\psi(x) $$ содержит 
    особенность и имеет простой вид, так что второй интеграл вычисляется аналитически.

    **Пример.** Рассмотрим интеграл по отрезку $$ [0, a] $$ от функции $$ y(x) $$:
    """)

    st.latex(r"""
        y(x) = \frac{1}{\sqrt{x (1 + x^2)}} = \left( \frac{1}{\sqrt{x (1 + x^2)}} - \frac{1}{\sqrt{x}} \right) 
        + \frac{1}{\sqrt{x}}.
    """)

    st.markdown("Здесь:")

    st.latex(r"""
            \varphi(x) = \frac{1}{\sqrt{x}} \left(\frac{1}{\sqrt{1 + x^2}} - 1\right) = 
            \frac{1 - \sqrt{1 + x^2}}{\sqrt{x} \sqrt{1 + x^2}} = 
            \frac{-x^{3/2}}{\sqrt{1 + x^2} \left(1 + \sqrt{1 + x^2}\right)}.
        """)

    st.markdown("""
    Имеет при $$ x \\to 0 $$ ограниченную производную, и интеграл от неё можно вычислить по стандартной программе.
    """)

    st.markdown("""
    **Приём 2** – мультипликативное выделение особенности. В этом случае:  
    $$y(x) = φ(x)\\psi(x)$$,$$φ(x) $$
    не имеет особенностей, $$\\psi(x) $$— интегрируемая функция.  
    С $$ \\psi(x) $$ как с весовой функцией можно построить
     квадратурную формулу стандартными методами.
    """)

    st.markdown("""
    **Приём 3** – построение нестандартных квадратурных формул с явным учётом особенности.

    **Пример.**
    """)

    st.latex(r"""
            F = \int_{-1}^1 \frac{e^x}{\sqrt{1 - x^2}}dx =\int_{x_m}^{x_{m+1}} \frac{e^x}{\sqrt{1 - x^2}} \, 
            dx = \sum_{m=1}^M e^{x_{m+1/2}} \int_{x_m}^{x_{m+1}} \frac{dx}{\sqrt{1 - x^2}} =
        """)
    st.latex(r"""
            = \sum_{m=1}^M e^{x_{m+1/2}} \left( \arcsin x_{m+1} - \arcsin x_m \right)  (x_1 = -1, \, x_{m+1} = 1).
        """)


# 11.2. Практические способы оценки погрешности приближенного решения в методах Рунге–Кутты
def runge_kutta_error_estimation():
    st.markdown("""
    ### 11.2. Практические способы оценки погрешности приближенного решения в методах Рунге–Кутты

    Пусть для решения ОДУ:
    """)
    st.latex(r"""
    y' = f(x, y), \quad y(x_0) = y_0 \tag{14}
    """)
    st.markdown("""
    используется некоторый метод Рунге–Кутты, имеющий порядок точности $$s$$. Это означает, что локальная погрешность 
    метода (погрешность на шаге) имеет вид:
    """)
    st.latex(r"""
    y(x_0 + h) - y_1 \equiv \psi(x_0, y_0) h^{s+1} \tag{15}
    """)
    st.markdown("""
    где $$y_1$$ – приближённое решение при $$x = x_0 + h$$.

    Обычно при создании программ интегрирования ОДУ для контроля точности применяют различные методы оценки именно 
    локальной погрешности метода. Рассмотрим два способа оценки.
    """)


# 11.2.1. Оценка погрешности по правилу Рунге
def runge_error_estimation_extended():
    st.markdown("""
    ### 11.2.1. Оценка погрешности по правилу Рунге

    Пусть по значению решения $$y_0$$ в точке $$x = x_0$$ получено решение $$\\overline{y}_1$$ в точке $$x = x_0 + h$$. 
    Погрешность этого приближённого значения имеет вид $$(15)$$. Вернемся в точку $$x_0$$ и сделаем подряд два шага 
    величины $$h / 2$$. 
    Пусть $$\\hat{y}$$ – приближение к решению $$y(x)$$ при $$x = x_0 + h / 2$$. Тогда:
    """)
    st.latex(r"""
    y(x_0 + h / 2) - \hat{y} = \psi(x_0, y_0) (h / 2)^{s+1}. \tag{16}
    """)

    st.markdown("""
    На втором шаге $$h / 2$$ из точки $$x = x_0 + h / 2$$ мы получим приближённое решение 
    $$\\overline{\\overline{y}}_1$$ в точке $$x = x_0 + h$$, его погрешность равна:
    """)
    st.latex(r"""
    \hat{y}(x_0 + h) - \overline{\overline{y}}_1 = \psi(x_0 + h / 2, \hat{y}) (h / 2)^{s+1}. \tag{17}
    """)

    st.markdown("""
    Здесь $$\\hat{y}(x)$$ – точное решение ОДУ, удовлетворяющее условию:
    """)
    st.latex(r"""
    \hat{y}(x = x_0 + h / 2) = \hat{y}.
    """)

    st.markdown("""
    Будем предполагать, что производные $$\\psi_x', \\psi_y'$$ ограничены. Тогда для достаточно малых шагов $$h$$:
    """)
    st.latex(r"""
    \psi(x_0 + h / 2, \hat{y}) \equiv \psi(x_0, y_0) + O(h),
    """)
    st.markdown("""
    и, следовательно, из $$(17)$$ имеем:
    """)
    st.latex(r"""
    \hat{y}(x_0 + h) - \overline{\overline{y}}_1 = \psi(x_0, y_0) (h / 2)^{s+1}.
    """)

    st.markdown("""
    С другой стороны:
    """)
    st.latex(r"""
    y(x_0 + h) - \hat{y}(x_0 + h) = \left[ y(x_0 + h / 2) + h / 2 f(x_0 + h / 2, \  y(x_0 + h / 2)) + \dots \right] - 
    """)
    st.latex(r"""
    - \left[ \hat{y}(x_0 + h / 2) + h / 2 f(x_0 + h / 2,\  \hat{y}(x_0 + h / 2)) + \dots \right] =
    """)
    st.latex(r"""
    = \left( y(x_0 + h / 2) - \hat{y}(x_0 + h / 2) \right) \times 
    """)
    st.latex(r"""
    \times \left[ 1 + h / 2 f'_y(x_0 + h / 2,\  \hat{y}(x_0 + h / 2)) + \dots \right]=
    """)
    st.latex(r"""
    = y(x_0 + h / 2) - \hat{y}(x_0 + h / 2) + O(h^{s+2}).
    """)

    st.markdown("""
        Следовательно:
        """)

    st.latex(r"""
        y(x_0 + h) - \overline{\overline{y}}_1 = \left[ y(x_0 + h) - \hat{y}(x_0 + h ) \right] + 
        \left[ \hat{y}(x_0 + h) - \overline{\overline{y}}_1 \right]\simeq
        """)
    st.latex(r"""
        \simeq \left[ y(x_0 + h / 2) - \hat{y}(x_0 + h / 2) \right] + \left[ \hat{y}(x_0 + h) - 
        \overline{\overline{y}}_1 \right] = 2 \psi(x_0, y_0) (h / 2)^{s+1}. \tag{18}
        """)

    st.markdown("""
        Из $$(15)$$ и $$(18)$$ следует, что:
        """)
    st.latex(r"""
        \psi(x_0, y_0) h^{s+1} = (\overline{\overline{y}}_1 - \overline{y}_1) / (1 - 1 / 2^s). \tag{19}
        """)
    st.markdown("""
        и
        """)
    st.latex(r"""
        2 \psi(x_0, y_0) (h / 2)^{s+1} = \frac{\overline{\overline{y}}_1 - \overline{y}_1}{2^s - 1}. \tag{20}
        """)

    st.markdown("""
        Очевидно, что оценка $$(20)$$ меньше по величине, чем $$(19)$$, т.е. значение $$y_1$$, полученное за два шага 
        $$h / 2$$, точнее, чем полученное за один шаг $$h$$. Приближённое значение $$\\overline{y}_1$$ или 
        $$\\overline{\\overline{y}}_1$$ можно уточнить, полагая:
        """)
    st.latex(r"""
        y_1 = \overline{y}_1 + (\overline{\overline{y}}_1 - \overline{y}_1) / (1 - 2^{-s}), \tag{21}
        """)
    st.markdown("""
        или
        """)
    st.latex(r"""
        y_1 = \overline{\overline{y}}_1 + (\overline{\overline{y}}_1 - \overline{y}_1) / (2^s - 1). \tag{22}
        """)

    st.markdown("""
        Тогда:
        """)
    st.latex(r"""
        y(x_1) - y_1 = O(h^{s+2}).
        """)

    st.markdown("""
        Для систем ОДУ записи $$(19)–(22)$$ используются покоординатно:
        """)
    st.latex(r"""
        y_1^{(i)}(x_0 + h) - \overline{y}_1^{(i)} \equiv \left( \overline{\overline{y}}_1^{(i)} - \overline{y}_1^{(i)} 
        \right) \big/ \Big(1 - 2^{-s}\Big).
        """)

    st.markdown("""
        или:
        """)

    st.latex(r"""
        y^{(i)}(x_0 + h) - \overline{\overline{y}}_1^{i} = \left( \overline{\overline{y}}_1^{(i)} - \overline{y}_1^{(i)}
         \right) \big/ \Big(2^s - 1\Big)\Big(i = 1, 2, \dots, M\Big).
        """)

    st.markdown("""
        При таком способе оценки локальной погрешности метод Рунге–Кутты на шаге используется три раза и требует $$3q - 1$$ вычислений правой части ОДУ. 
        Поэтому при сложных правых частях он не применяется.
        """)
