import streamlit as st
import numpy as np
import matplotlib.pyplot as plt
from streamlit_ace import st_ace

from scipy.integrate import odeint
from scipy.optimize import fsolve
import time

import time
import io
import sys


elif task == "Метод наименьших квадратов":
    st.header("3. Метод наименьших квадратов для аппроксимации")

    st.markdown("""
    Метод наименьших квадратов (МНК) используется для приближения функций, когда данные могут содержать шум, и требуется найти функцию, которая минимизирует среднеквадратичное отклонение от наблюдаемых данных. МНК широко применяется для решения задач регрессии, где ищется прямая или многочлен, наилучшим образом описывающий набор точек.
    """)

    st.latex(r"""
    \textbf{Теоретическая основа:} \\
    Цель метода \, наименьших \, квадратов \, заключается \, в \, минимизации \, суммы \, квадратов \, отклонений \, между \, наблюдаемыми \, значениями \, y_i \, и \, вычисленными \, значениями \, функции \, f(x):
    """)
    st.latex(r"""
    S(a_0, a_1, \dots, a_m) = \sum_{i=1}^{N} \rho_i \left( y_i - f(x_i, a_0, a_1, \dots, a_m) \right)^2
    """)
    st.latex(r"""
    где \, \rho_i \, — весовые \, коэффициенты, \, N \, — количество \, наблюдений, \, а \, f(x) \, представляет \, аппроксимирующую \, функцию.
    """)

    st.markdown("**Реализация на чистом Python:**")
    st.code("""
def least_squares_method(x, y):
    '''Метод наименьших квадратов для линейной аппроксимации: y = a0 + a1 * x'''
    N = len(x)

    # Вычисляем суммы
    S0 = N
    S1 = sum(x)
    S2 = sum(xi**2 for xi in x)
    T0 = sum(y)
    T1 = sum(yi * xi for yi, xi in zip(y, x))

    # Решаем систему уравнений
    a1 = (T1 * S0 - T0 * S1) / (S2 * S0 - S1**2)
    a0 = (T0 - S1 * a1) / S0

    return a0, a1

# Пример данных
x_points = [0, 1, 2, 3, 4]
y_points = [1, 2, 1, 0, 4]

# Применение метода наименьших квадратов
a0, a1 = least_squares_method(x_points, y_points)

# Вывод приближающей прямой
print(f"Приближающая прямая: y = {a0:.2f} + {a1:.2f} * x")

# Тестирование аппроксимации для x = 2.5
x_test = 2.5
y_test = a0 + a1 * x_test
print(f"Приближённое значение y при x = {x_test}: {y_test:.2f}")
    """)

    st.markdown("""
    Этот код демонстрирует базовую реализацию метода наименьших квадратов для линейной аппроксимации на языке Python. Пользователь может задать свои данные для аппроксимации и получить линейную функцию, которая минимизирует среднеквадратичное отклонение.
    """)

    st.markdown("**Преимущества:**")
    st.markdown("""
    - Простота реализации.
    - Способность учитывать шум в данных и искать наилучшую аппроксимирующую функцию.
    """)

    st.markdown("**Недостатки:**")
    st.markdown("""
    - Ограниченная применимость для сложных функций без использования полиномов более высокой степени.
    - Не всегда подходит для сильно зашумленных данных.
    """)

    st.markdown("**Алгоритм:**")
    st.latex(r"""
    1. \, Собрать \, данные \, (x_i, y_i). \\
    2. \, Вычислить \, необходимые \, суммы \, (S_0, S_1, S_2, T_0, T_1). \\
    3. \, Решить \, систему \, линейных \, уравнений \, для \, нахождения \, коэффициентов \, a_0 \, и \, a_1. \\
    4. \, Использовать \, эти \, коэффициенты \, для \, построения \, аппроксимирующей \, функции.
    """)

# Демонстрация работы метода наименьших квадратов
def least_squares_method(x, y):
    '''Метод наименьших квадратов для линейной аппроксимации: y = a0 + a1 * x'''
    N = len(x)

    # Вычисляем суммы
    S0 = N
    S1 = sum(x)
    S2 = sum(xi**2 for xi in x)
    T0 = sum(y)
    T1 = sum(yi * xi for yi, xi in zip(y, x))

    # Решаем систему уравнений
    a1 = (T1 * S0 - T0 * S1) / (S2 * S0 - S1**2)
    a0 = (T0 - S1 * a1) / S0

    return a0, a1

# Пример данных
x_points = [0, 1, 2, 3, 4]
y_points = [1, 2, 1, 0, 4]

# Применение метода наименьших квадратов
a0, a1 = least_squares_method(x_points, y_points)

# Демонстрация работы
def f(x):
    return a0 + a1 * x

x_range = [i for i in range(-1, 6)]
y_approx = [f(x) for x in x_range]

import matplotlib.pyplot as plt
fig, ax = plt.subplots()
ax.plot(x_range, y_approx, label='Приближение МНК')
ax.scatter(x_points, y_points, color='red', label='Исходные данные')
ax.legend()
plt.show()

elif task == "Линейная аппроксимация с помощью системы функций":
st.header("Линейная аппроксимация с помощью системы функций")

st.markdown("""
    Линейная аппроксимация — это метод приближения функции с использованием линейной комбинации некоторых функций. Аппроксимация строится с помощью системы линейно независимых функций \( f_k(x) \), где \( k = 0, 1, ..., M \).
    """)

st.latex(r"""
    \textbf{Теоретическая основа:} \\
    Приближение функции \( y(x) \) на отрезке \( [a, b] \) можно представить в виде линейной комбинации:
    y_M(x) = a_0 f_0(x) + a_1 f_1(x) + ... + a_M f_M(x)
    """)

st.markdown("""
    Задача заключается в нахождении таких коэффициентов \( a_0, a_1, ..., a_M \), чтобы минимизировать среднеквадратичное отклонение между реальной функцией \( y(x) \) и её приближением \( y_M(x) \). Это можно записать в виде функционала:
    """)

st.latex(r"""
    f(a_0, a_1, ..., a_M) = \int_a^b \rho(x) \left[ y(x) - y_M(x) \right]^2 dx
    """)

st.markdown("""
    Здесь \( \rho(x) \) — весовая функция, а система функций \( f_0, f_1, ..., f_M \) должна быть линейно независимой.

    Для нахождения коэффициентов \( a_k \), система уравнений выводится из условия минимизации, что приводит к следующей системе:
    """)

st.latex(r"""
    \sum_{m=0}^{M} (f_k, f_m) a_m = (y, f_k), \quad k = 0, 1, ..., M
    """)

st.markdown("""
    Эта система линейных уравнений решается для нахождения коэффициентов \( a_k \), где \( (f_k, f_m) \) — это скалярное произведение функций:
    """)

st.latex(r"""
    (f_k, f_m) = \int_a^b \rho(x) f_k(x) f_m(x) dx
    """)

st.markdown("**Реализация на чистом Python:**")
st.code("""
def scalar_product(f, g, a, b, rho=lambda x: 1, n=1000):
   
Численное
вычисление
скалярного
произведения
функций
f
и
g
на
отрезке[a, b]
с
весовой
функцией
rho.

    h = (b - a) / n
    result = 0
    for i in range(n):
        x = a + i * h
        result += rho(x) * f(x) * g(x) * h
    return result

def linear_approximation(y, f_list, a, b, rho=lambda x: 1, n=1000):
   
Линейная
аппроксимация
функции
y
с
помощью
системы
функций
f_list
на
отрезке[a, b].

    M = len(f_list) - 1
    A = [[scalar_product(f_list[i], f_list[j], a, b, rho, n) for j in range(M+1)] for i in range(M+1)]
    B = [scalar_product(y, f_list[i], a, b, rho, n) for i in range(M+1)]

    # Решение системы линейных уравнений A * a = B
    a_coeffs = np.linalg.solve(A, B)

    def y_approx(x):
        return sum(a_coeffs[i] * f_list[i](x) for i in range(M+1))

    return y_approx, a_coeffs

# Пример использования
def f0(x):
    return 1

def f1(x):
    return x

def f2(x):
    return x**2

f_list = [f0, f1, f2]

# Приближение функции y(x) = sin(x) на отрезке [0, pi]
import math
y = lambda x: math.sin(x)
a, b = 0, math.pi
y_approx, coeffs = linear_approximation(y, f_list, a, b)

print("Коэффициенты аппроксимации:", coeffs)

# Тестирование аппроксимации в точке x = pi / 2
test_x = math.pi / 2
print("Значение аппроксимированной функции в точке pi/2:", y_approx(test_x))
print("Истинное значение sin(pi/2):", y(test_x))
    """)

st.markdown("""
    Этот код демонстрирует реализацию линейной аппроксимации на языке Python. Он использует набор линейно независимых функций для приближения реальной функции.
    """)

st.markdown("**Преимущества:**")
st.markdown("""
    - Гибкость выбора аппроксимирующих функций.
    - Легкость вычислений при небольшом числе функций.
    """)

st.markdown("**Недостатки:**")
st.markdown("""
    - Возрастающая сложность системы уравнений при увеличении числа функций.
    - Возможные трудности с выбором подходящих функций для аппроксимации.
    """)

st.markdown("**Алгоритм:**")
st.latex(r"""
    1. \, Выбрать \, систему \, функций \, f_k(x), \, k = 0, 1, ..., M. \\
    2. \, Вычислить \, скалярные \, произведения \, (f_k, f_m) \, и \, (y, f_k). \\
    3. \, Решить \, систему \, линейных \, уравнений \, для \, нахождения \, коэффициентов \, a_k. \\
    4. \, Использовать \, найденные \, коэффициенты \, для \, построения \, аппроксимирующей \, функции.
    """)


# Демонстрация работы линейной аппроксимации
def f(x):
    return math.sin(x)


num_points = st.slider("Выберите количество узлов для визуализации", 10, 50, 10)
x_points = [i * math.pi / (num_points - 1) for i in range(num_points)]
y_points = [f(x) for x in x_points]

y_approx, _ = linear_approximation(f, f_list, 0, math.pi)

x_range = [i * math.pi / 100 for i in range(100)]
y_approx_values = [y_approx(x) for x in x_range]
y_true_values = [f(x) for x in x_range]

import matplotlib.pyplot as plt

fig, ax = plt.subplots()
ax.plot(x_range, y_true_values, label='Исходная функция')
ax.plot(x_range, y_approx_values, label='Приближение')
ax.scatter(x_points, y_points, color='red', label='Точки')
ax.legend()
st.pyplot(fig)

# Метод наименьших квадратов (МНК)
elif task == "Метод наименьших квадратов":
st.header("3. Метод наименьших квадратов (МНК)")

st.markdown("""
    Метод наименьших квадратов — это метод аппроксимации функций, основанный на минимизации суммы квадратов отклонений аппроксимируемой функции от её модели. 
    Это позволяет аппроксимировать данные, даже если они содержат шум.
    """)

st.latex(r"""
    \textbf{Теоретическая основа:} \\
    Пусть даны значения \( y_i \) в точках \( x_i \), где \( i = 1, 2, \dots, N \). Необходимо найти такую функцию \( y(x) \), которая минимизирует сумму квадратов отклонений: \\
    f(a_0, a_1, \dots, a_M) = \sum_{i=1}^{N} \rho_i [y_i - y(x_i)]^2 \\
    где \, y(x) = a_0 + a_1 x + \dots + a_M x^M
    """)

st.latex(r"""
    Система уравнений для нахождения коэффициентов \( a_0, a_1, \dots, a_M \) получается из условия минимума: \\
    \frac{\partial f}{\partial a_k} = 0, \quad k = 0, 1, \dots, M
    """)

st.markdown("""
    Решение этой системы позволяет найти коэффициенты многочлена, который аппроксимирует исходные данные методом наименьших квадратов.
    """)

st.markdown("**Реализация на чистом Python:**")
st.code("""
def least_squares(x_points, y_points, degree):
    n = len(x_points)
    A = [[sum(x**(i+j) for x in x_points) for j in range(degree+1)] for i in range(degree+1)]
    B = [sum(y * (x**i) for x, y in zip(x_points, y_points)) for i in range(degree+1)]

    # Решаем систему уравнений A * coeffs = B для нахождения коэффициентов
    coeffs = solve(A, B)
    return coeffs

# Пример данных
x_points = [0, 1, 2, 3]
y_points = [1, 1, 2, 2]

# Нахождение коэффициентов многочлена степени 1 (линейная аппроксимация)
coeffs = least_squares(x_points, y_points, 1)
print("Коэффициенты многочлена:", coeffs)
    """)

st.markdown("""
    Этот код демонстрирует, как можно реализовать метод наименьших квадратов для линейной аппроксимации на языке Python. Пользователь может изменить узлы \( x_i \) и значения \( y_i \), чтобы исследовать работу метода для различных наборов данных.
    """)

st.markdown("**Преимущества:**")
st.markdown("""
    - Метод устойчив к шумам в данных.
    - Гибкость в выборе степени многочлена.
    """)

st.markdown("**Недостатки:**")
st.markdown("""
    - Требует решения системы линейных уравнений, что может быть вычислительно сложно при высоких степенях многочлена.
    - Полиномы высокой степени могут плохо аппроксимировать данные из-за переобучения.
    """)

st.markdown("**Алгоритм:**")
st.latex(r"""
    1. \, Задаём \, узлы \, аппроксимации \, x_i \, и \, значения \, y_i. \\
    2. \, Формируем \, систему \, линейных \, уравнений \, для \, нахождения \, коэффициентов \, многочлена. \\
    3. \, Решаем \, систему \, и \, вычисляем \, коэффициенты.
    """)


# Демонстрация работы метода наименьших квадратов
def f(x):
    return 2 * x + 1


num_points = st.slider("Выберите количество узлов аппроксимации", 2, 10, 5)
x_points = [i for i in range(num_points)]
y_points = [f(x) + np.random.normal(0, 0.2) for x in x_points]  # Добавляем шум

coeffs = least_squares(x_points, y_points, 1)
y_approx = [sum(c * (x ** i) for i, c in enumerate(coeffs)) for x in x_points]

import matplotlib.pyplot as plt

fig, ax = plt.subplots()
ax.plot(x_points, y_points, 'o', label='Исходные данные')
ax.plot(x_points, y_approx, label='Аппроксимация МНК')
ax.legend()
st.pyplot(fig)


