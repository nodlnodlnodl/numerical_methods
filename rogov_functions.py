import streamlit as st
def mnk():
    st.write("### 3.4. Среднеквадратичное приближение (метод наименьших квадратов)")

    st.write("""
    До сих пор, рассматривая приближение функций, мы для их построения использовали критерий точного прохождения интерполирующей функции через узловые точки. Точность такой аппроксимации, как правило, гарантирована в небольшом интервале вблизи середины множества используемых узлов. Кроме того, нередки ситуации, когда опорные точки сильно искажены шумом (например, экспериментально измеренные значения некоторой величины со случайной ошибкой).
    
    Таким образом, если ставится задача получения достаточно точного приближения для функции \\( y(x) \\) на заданном отрезке \\( a \\leq x \\leq b \\) или же значения \\( y \\) в узловых точках \\( x_1, x_2, ..., x_N \\) сильно зашумлены, то широко используются методы, основанные на приближении в среднем. При этом наиболее распространённым методом является метод, основанный на минимизации среднеквадратичного отклонения (метод наименьших квадратов – МНК).
    """)

def mnogochlen_approksimashion():
    st.write("### 3.4.1. Дискретное задание функции, многомерная аппроксимация")

    st.write("""
    Пусть измеряется некоторая величина \\( y \\) и сделано \\( N \\) измерений, в ходе которых получены значения \\( y_1, y_2, ..., y_N \\). Предположим, что ошибки измерений:
    """)
    st.latex(r"\varepsilon_i = y - y_i")
    st.write("""
    имеют случайный характер, независимы и:
    """)
    st.latex(r"\sum_{i=1}^N \varepsilon_i = 0.")
    st.write("""
    В этом случае в качестве оценки \\( \overline{y} \\) величины \\( y \\) выбирается такое значение, которое минимизирует сумму квадратов ошибок:
    """)
    st.latex(r"f(\overline{y}) = \sum_{i=1}^N \varepsilon_i^2 = \sum_{i=1}^N (y - y_i)^2.")
    st.write("""
    Определим это значение \\( \overline{y} \\). Из условия минимума \\( f(y) \\) имеем:
    """)
    st.latex(r"\frac{\partial f}{\partial y} \Bigg|_{y=\overline{y}} = 2 \sum_{i=1}^N (\overline{y} - y_i) = 0.")
    st.write("""
    Следовательно:
    """)
    st.latex(r"\overline{y} = \frac{1}{N} \sum_{i=1}^N y_i.")
    st.write("""
    Таким образом, хорошо известный результат: среднее арифметическое в качестве оценки измеряемой величины берётся среднее значение нескольких измерений.
    """)

    st.write("### Многомерная аппроксимация")
    st.write("""
    На практике часто измеряется отклик некоторой системы на изменение внешних параметров. В этом случае измерения \\( y \\) выполняются в зависимости от параметра \\( x \\), т.е. получают значения функции \\( y(x) \\).
    
    Один из наиболее общих случаев применения МНК – аппроксимация полиномом:
    """)
    st.latex(r"y(x) = a_0 + a_1 x + \dots + a_M x^M.")
    st.write("""
    Минимизируется следующая функция:
    """)
    st.latex(r"f(a_0, a_1, ..., a_M) = \sum_{i=1}^N \rho_i [y_i - y(x_i)]^2,")
    st.write("""
    где \\( \rho_i \\) – положительные веса. Если измерения равновесны, то \\( \rho_i = 1 \\). Функция минимизируется для нахождения коэффициентов \\( a_0, a_1, ..., a_M \\).
    """)

    st.write("#### Пример")
    st.write("""
    Дана таблица:
    """)
    st.write("""
    | x   | 0 | 1 | 2 | 3 | 4 |\n|-----|---|---|---|---|---|\n| y   | 1 | 2 | 1 | 2 | 4 |
    """)
    st.write("Требуется аппроксимировать \\( y(x) \\) прямой:")
    st.latex(r"y(x) = a_0 + a_1 x.")
    st.write("""
    Считаем суммы:
    """)
    st.latex(r"""
    S_0 = \sum x^0, \quad S_1 = \sum x, \quad S_2 = \sum x^2, \quad T_0 = \sum y, \quad T_1 = \sum xy.
    """)
    st.write("Находим коэффициенты:")
    st.latex(r"a_0 = \frac{4}{5}, \quad a_1 = \frac{2}{5}.")
    st.write("Итоговая прямая:")
    st.latex(r"y(x) = \frac{2}{5} x + \frac{4}{5}.")

def linear_approcsimation():
    st.write("### 3.4.2. Непрерывное задание функции, линейная аппроксимация")

    st.write(
        r"Пусть на отрезке \(a \leq x \leq b\) задана некоторая функция \(y(x)\) и её надо аппроксимировать "
        r"с помощью линейной комбинации некоторых функций \(f_k(x), \ k = 0, 1, \dots, M:\)"
    )
    st.latex(r"y_M = a_0 f_0 + a_1 f_1 + \dots + a_M f_M")

    st.write(
        r"Таким образом, чтобы \(f(a_0, a_1, \dots, a_M) = \int_a^b \rho(x) [y(x) - y_M(x)]^2 dx\) "
        r"имела наименьшее значение, где \(\rho(x)\) — весовая функция, "
        r"предполагается положительной, а система функций \(f_0, f_1, \dots, f_M\) — линейно независимой."
    )

    st.write(r"Введём обозначение (скалярное произведение функций \(q(x), \phi(x)\)) как:")
    st.latex(r"(q, \phi) = \int_a^b \rho q \phi dx")

    st.write(r"Используя это обозначение, получим:")
    st.latex(
        r"f(a_0, a_1, \dots, a_M) = (y, y) - 2 \sum_{k=0}^M a_k (y, f_k) + \sum_{k,m=0}^M a_k a_m (f_k, f_m)"
    )

    st.write(
        r"Приравнивая к нулю производные от \(f\) по \(a_0, \dots, a_M\), получим систему уравнений:"
    )
    st.latex(r"\sum_{m=0}^M (f_k, f_m) a_m = (y, f_k), \quad k = 0, 1, \dots, M.")

    st.write(
        r"Её определитель \(\Delta = \det((f_k, f_m))\), называется определителем Грама функций \(f_k\). "
        r"Для линейно независимых систем \(\Delta \neq 0\), поэтому система всегда имеет решение."
    )

    st.write(
        r"Однако на практике непосредственно систему (22) при \(M \geq 5\) решать сложно, так как "
        r"определитель Грама с ростом \(M\) быстро убывает, что делает систему (22) малопригодной для вычислений."
    )

    st.write(
        r"Положение сильно упрощается, если \(f_0, \dots, f_M\) образуют систему ортогональных функций."
    )


def ortogonal():
    st.write("### 3.4.3. Ортогональные функции")

    st.write("Рассмотрим теперь некоторые общие теоремы, поясняющие свойства ортогональных функций.")

    st.write(
        "Определение 3. Функции f_0, f_1, ..., f_M называются линейно независимыми на отрезке [a, b], если из равенства")
    st.write("a_0 f_0 + a_1 f_1 + ... + a_M f_M = 0 на всём отрезке следует a_0 = 0, a_1 = 0, ..., a_M = 0.")

    st.write("Пример. Функции 1, x, ..., x^M линейно независимы на любом отрезке [a, b], так как многочлен")
    st.write("a_0 + a_1 x + ... + a_M x^M согласно основной теореме алгебры имеет не более M корней.")

    st.write("Теорема 1. Любая система непрерывных ортогональных на отрезке [a, b] функций линейно независима.")

    st.write("В самом деле, если f_0, f_1, ..., f_M — такая система и a_0 f_0 + ... + a_M f_M ≡ 0 при a ≤ x ≤ b,")
    st.write("то для коэффициентов имеем a_j = 1/λ_j ∫[a, b] ρ · 0 · f_j dx = 0.")

    st.write("Теорема 2. Из любой системы линейно независимых функций f_0, f_1, ..., f_M на отрезке [a, b]")
    st.write("можно получить систему ортогональных функций на этом отрезке.")

    st.write("Доказательство. Рассмотрим следующий процесс (он называется процессом ортогонализации Шмидта):")

    st.latex(r"\lambda_0 = \int_a^b \rho(x) f_0^2 dx \quad (\rho(x) \geq 0 \text{ по условию})")

    st.write("тогда равенство g_0(x) = f_0(x)/√λ_0 приводит нас к нормированной функции g_0(x).")

    st.write("Пусть построены первые j ортонормированных функций g_i(x), i = 0, ..., j - 1.")

    st.write("Положим F_j(x) = a_0 g_0 + ... + a_{j-1} g_{j-1} + f_j(x).")

    st.write(
        "Функция F_j отлична от нуля, так как f_j линейно независимы, а каждая из g_i — линейная комбинация f_k, k ≤ i.")

    st.write("Определим a_0, ..., a_{j-1} из условий ортогональности F_j функциям g_0, ..., g_{j-1}:")

    st.latex(r"\int_a^b \rho F_j g_i dx = 0, \quad i = 0, 1, \dots, j - 1")

    st.write("Отсюда находим, подставляя выражение для F_j, что a_i + ∫[a, b] ρ f_j g_i dx = 0, i = 0, 1, ..., j - 1.")

    st.write("Следовательно, F_j(x) определена, функцию g_j определим так: g_j(x) = F_j(x)/√λ_j;")

    st.latex(r"\lambda_j = \int_a^b \rho F_j^2 dx")

    st.write("Таким образом, шаг по индукции выполнен.")

    st.write("Замечание. На практике процесс ортогонализации Шмидта редко применяется для значений M ≥ 5.")

    st.write(
        "Дело в том, что при численной ортогонализации потребности вычисления быстро приводят к тому, что очередная ортогональная функция становится малой.")

    st.write(
        "При нормировке ошибка только возрастает. Поэтому обычно пользуются аналитическими ортогональными системами функций.")

    st.write("Теорема 3. Коэффициенты Фурье {a_j} функции F(x) относительно ортонормированного семейства {g_j}")
    st.write("на отрезке [a, b] удовлетворяют неравенству Бесселя: ∑_{j=0}^M a_j^2 ≤ ∫[a, b] ρ F^2 dx.")

    st.write("Доказательство. Запишем очевидное неравенство:")

    st.latex(r"\int_a^b \rho \left(F - \sum_{i=0}^M a_i g_i(x)\right)^2 dx \geq 0")

    st.write("и раскроем скобки")

    st.latex(
        r"0 \leq \int_a^b \rho F^2 dx - 2 \int_a^b \rho F \sum_{i=0}^M a_i g_i(x) dx "
        r"+ \int_a^b \rho \sum_{i=0}^M \sum_{j=0}^M a_i a_j g_i g_j dx ="
    )
    st.latex(
        r"= \int_a^b \rho F^2 dx - 2 \sum_{i=0}^M a_i^2 + \sum_{j=0}^M a_j^2."
    )

    st.write("Теорема 4")
    st.write(
        "Коэффициенты Фурье \\( $\\{a_j$\\} \\) дают наилучшее в смысле наименьших квадратов приближение, "
        "когда \\( y(x) \\) разлагается по ортонормированному множеству функций \\( $\\{g_j(x)$\\} \\) на отрезке \\([a, b]\\)."
    )
    st.write(
        "**Доказательство.** Пусть на отрезке \\([a, b]\\) задана функция \\(y(x)\\), которую мы хотим приблизить линейной комбинацией функций \\(g_j(x)\\):")
    st.latex(r"y_M = \sum_{j=0}^M C_j g_j(x)")
    st.write(
        "наилучшей в смысле МНК, т.е. хотим подобрать коэффициенты \\(C_0, ..., C_M\\) так, чтобы функция"
    )
    st.latex(r"f(C_0, ..., C_M) = \int_a^b \rho [y(x) - y_M]^2 dx")
    st.write(
        "была минимальной; весовой множитель \\( \\rho(x) \\) считаем неотрицательным."
    )

    st.write("Пусть")
    st.latex(r"a_j = \int_a^b \rho y g_j(x) dx, \quad j = 0, ..., M")
    st.write(
        "— коэффициенты Фурье для \\(y(x)\\) относительно семейства \\(\\{g_j(x)\\}\\). "
        "Преобразуем \\(f(C_0, ..., C_M)\\) следующим образом:"
    )
    st.latex(
        r"f(C_0, ..., C_M) = \int_a^b \rho y^2 dx - 2 \sum_{j=0}^M C_j \int_a^b \rho y g_j dx"
    )
    st.latex(
        r"+ \sum_{j=0}^M \sum_{i=0}^M C_j C_i \int_a^b \rho g_j g_i dx ="
    )
    st.latex(
        r"= \int_a^b \rho y^2 dx - 2 \sum_{j=0}^M C_j a_j + \sum_{j=0}^M a_j^2 + \sum_{j=0}^M (a_j - C_j)^2."
    )
    st.write("Последнее выражение минимально, если \\(C_j = a_j\\), что и требовалось доказать.")
