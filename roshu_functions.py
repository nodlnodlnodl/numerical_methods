import streamlit as st
import numpy as np
import matplotlib.pyplot as plt
from streamlit_ace import st_ace

import matplotlib.pyplot as plt

import pandas as pd

from code_editor import code_editor
from scipy.integrate import odeint
from scipy.optimize import fsolve
import time

import time
import io
import sys



def gauss_elimination_method():
    st.write("## 6.4 Прямые методы решения систем линейных уравнений")
    st.write("### 6.4.1 Метод исключения Гаусса")

    st.write("""
    Для систем линейных уравнений $$Ax = b$$ с заполненной матрицей $$A$$, хранящейся в оперативной памяти машины, не найдено алгоритмов решения, лучших по времени и точности, чем метод последовательного исключения Гаусса. Основной его идеей является представление матрицы $$A$$ в виде LU-разложения. Если для $$A$$ известно такое разложение, то решение исходной системы сводится к решению уравнений:
    
    $$
    Ly = b, \quad Ux = y,
    $$
    
    которые легко решаются, поскольку $$L$$ и $$U$$ имеют вид:
    """)

    st.latex(r"""
    L = \begin{pmatrix}
    1 & 0 & 0 & \dots & 0 \\
    m_{21} & 1 & 0 & \dots & 0 \\
    m_{31} & m_{32} & 1 & \dots & 0 \\
    \vdots & \vdots & \vdots & \ddots & \vdots \\
    m_{n1} & m_{n2} & m_{n3} & \dots & 1 \\
    \end{pmatrix},
    \quad
    U = \begin{pmatrix}
    U_{11} & U_{12} & U_{13} & \dots & U_{1n} \\
    0 & U_{22} & U_{23} & \dots & U_{2n} \\
    0 & 0 & U_{33} & \dots & U_{3n} \\
    \vdots & \vdots & \vdots & \ddots & \vdots \\
    0 & 0 & 0 & \dots & U_{nn} \\
    \end{pmatrix}
    """)

    st.write("""
    Из первой системы последовательно находим $$y_1, y_2, \dots, y_n$$ (прямое исключение), из второй $$x_n, x_{n-1}, \dots, x_1$$ (обратная подстановка).
    
    Рассмотрим теперь классический метод исключения Гаусса и выведем попутно на его основе выражения для матриц $$L, U$$. Запишем исходную систему в виде:
    """)

    st.latex(r"""
    \begin{aligned}
    a_{11}x_1 + a_{12}x_2 + \dots + a_{1n}x_n &= b_1, \\
    a_{21}x_1 + a_{22}x_2 + \dots + a_{2n}x_n &= b_2, \\
    \vdots \\
    a_{n1}x_1 + a_{n2}x_2 + \dots + a_{nn}x_n &= b_n.
    \end{aligned}
    """)

    st.write("""
    Предположим, что $$a_{11} \neq 0$$, и образуем числа $$m_{i1} = a_{i1}/a_{11}$$, $$i = 2, 3, \dots, n$$. Умножая первое уравнение на $$m_{i1}$$ и вычитая результат из $$i$$-го уравнения $$(i = 2, \dots, n$$), придем к новой системе, в которой уравнения с номерами $$i \geq 2$$ не содержат $$x_1$$. Это преобразование эквивалентно умножению системы $$Ax = b$$ слева на матрицу:
    """)

    st.latex(r"""
    M_1 = \begin{pmatrix}
    1 & 0 & 0 & \dots & 0 \\
    -m_{21} & 1 & 0 & \dots & 0 \\
    -m_{31} & 0 & 1 & \dots & 0 \\
    \vdots & \vdots & \vdots & \ddots & \vdots \\
    -m_{n1} & 0 & 0 & \dots & 1 \\
    \end{pmatrix}
    """)

    st.write("""
    В результате приходим к системе:
    """)

    st.latex(r"""
    A^{(2)} x = b^{(2)}
    """)

    st.write("""
    где
    """)

    st.latex(r"""
    A^{(2)} = \begin{pmatrix}
    a_{11} & a_{12} & \dots & a_{1n} \\
    0 & a^{(2)}_{22} & \dots & a^{(2)}_{2n} \\
    0 & 0 & \dots & a^{(2)}_{nn}
    \end{pmatrix}, \quad
    b^{(2)} = \begin{pmatrix}
    b_1 \\
    b_2 - m_{21}b_1 \\
    b_3 - m_{31}b_1
    \end{pmatrix}
    """)

    st.write("""
    Пусть в (11) $$a^{(2)}_{22} \neq 0$$, составим числа $$m_{i2} = a_{i2}^{(2)} / a_{22}^{(2)}$$, $$i = 3, \dots, n$$, и умножим на них второе уравнение, затем вычтем из каждого последующего. После этих преобразований получится матрица:
    """)

    st.latex(r"""
    M_2 = \begin{pmatrix}
    1 & 0 & 0 & \dots & 0 \\
    0 & 1 & 0 & \dots & 0 \\
    0 & -m_{32} & 1 & \dots & 0 \\
    \vdots & \vdots & \vdots & \ddots & \vdots \\
    0 & -m_{n2} & 0 & \dots & 1
    \end{pmatrix}
    """)

    st.write("""
    Умножая $$ (11) $$ на $$M_2$$ слева, приходим к системе:
    
    $$
    A^{(3)} x = b^{(3)},
    $$
    
    в которой уравнения, начиная с третьего, не содержат $$x_1, x_2$$. На практике не формируют матрицу $$M_2$$, а делают, как и на первом шаге, исключение $$x_2$$ из третьего, четвертого и так далее уравнений с помощью элементарных преобразований. Проделав подобную процедуру $$ (n - 1) $$ раз, придем к системе вида:
    """)

    st.latex(r"""
    \begin{aligned}
    a^{(n)}_{nn}x_n &= b^{(n)}_n \\
    0 &= b^{(n)}_{n-1} \\
    \vdots \\
    0 &= b^{(n)}_2 \\
    0 &= b^{(n)}_1
    \end{aligned}
    """)

    st.write("""
    Решение этой системы очевидно. Сформулируем теперь получение результата $$ (12) $$ в матричном виде. Как следует из предыдущего, $$ (12) $$ возникает при умножении $$ (10) $$ слева на $$ M = M_{n-1} \dots M_1 $$, т.е. $$ M = L^{-1} $$, где $$L$$ — нижняя треугольная матрица для $$A$$. Поэтому:
    """)

    st.latex(r"""
    A = M^{-1}U.
    """)

    st.write("""
    Но $$M^{-1} = L$$, нетрудно убедиться, что $$M^{-1}_k$$ есть матрица $$M_k$$ с измененными знаками у элементов ниже диагонали. В самом деле, пусть $$C = (c_{ij})$$, $$F = (f_{ij})$$ — две нижние треугольные $$ (n \times n) $$-матрицы с единицами на диагонали. Тогда:
    
    $$
    b_{ij} = (CF)_{ij} = \sum_{s \leq i} c_{is} f_{sj}.
    $$
    
    Откуда видно, что $$b_{ij} = 1$$, $$b_{ij} = 0$$ при $$i < j$$, т.е. $$B = CF$$ — нижняя треугольная матрица с единичной диагональю. Пусть теперь $$C = M_k$$, $$F$$ равна матрице $$M_k$$ с элементами противоположного знака в $$k$$-м столбце. Тогда:
    
    $$
    b_{ij} = (CF)_{ij} = \sum_{s \leq i} c_{is} f_{sj} = \delta_{ij}.
    $$
    
    Таким образом, $$b_{ij} = \delta_{ij}$$. Следовательно, $$L = M^{-1}$$ — нижняя треугольная матрица. Если хранить матрицы $$L, U$$ на месте матрицы $$A$$, то (единицы для $$(L$$ не храним!) вместо $$A$$ получим:
    """)

    st.write("""
    Таким образом, метод последовательного исключения Гаусса привел нас к разложению матрицы $$A$$ в $$LU$$-произведение. Сделаем некоторые замечания.
    """)

    st.write("### Замечания:")

    st.write("""
    1. Если разложение (13) получено, то, согласно LU-теореме:
    
    $$
    \det A = U_{11} U_{22} \dots U_{nn}.
    $$
    """)

    st.write("""
    2. Если на каком-то $$k$$-этапе окажется, что $$a^{(k)}_{kk} = 0$$, т.е. на главной диагонали появится нулевой элемент, то исключение Гаусса далее с ним производить нельзя. Но все элементы $$a_{ik}, i > k$$, не могут быть нулями, так как это означает, что $$ \det A = 0 $$. Перестановкой строк к $$k$$-й строке можно добиться, чтобы $$a^{(k)}_{kk} \\neq 0$$, и вычисления можно продолжить. На практике обычно перестановка строк осуществляется выбором $$a^{(k)}_{kk}$$, являющегося максимальным по модулю из элементов ниже диагонали.
    """)

    st.write("""
    Решим систему, выполняя действия на машине с тремя десятичными знаками и плавающей запятой:
    
    $$
    0.000100x_1 + 1.00x_2 = 1.00, \\
    -10000x_2 = -10000 \quad \Rightarrow x_2 = 1.00, \\
    1.00x_1 = 1.00 \quad \Rightarrow x_1 = 1.00.
    $$
    
    Истинное решение этой системы есть:
    """)

    st.latex(r"""
    x_1 = 10000, \quad x_2 = 9999.
    """)

    st.write("""
    Этот метод дает экономичный способ построения обратной матрицы $$A^{-1}$$. Для этого можно использовать матричное уравнение вида:
    
    $$
    AA^{-1} = E.
    $$
    """)

def reflection_method():

    st.title("6.4.2 Метод отражений")

    st.write("""
    Напомним, что для произвольного вектора $\\vec{S}$ легко построить матрицу отражения такую, что $U \\cdot \\vec{S} = \\alpha \\cdot \\vec{I}$, где $\\vec{I}$ — единичный вектор заданного направления. Для этого надо взять:
    """)
    st.latex(r"""
    W = \frac{1}{\rho}(\vec{S} - \alpha \vec{I}),
    """)
    st.write("""
    где
    """)
    st.latex(r"""
    \alpha = (\vec{S}, \vec{I}), \quad |\alpha| = |(\vec{S}, \vec{I})|, \quad \text{arg} = \text{arg}(\vec{S}, \vec{I}) - \pi,
    """)
    st.latex(r"""
    \rho = |\vec{S} - \alpha \vec{I}| = \sqrt{2|\alpha|^2 + 2| (\vec{S}, \vec{I}) |}.
    """)

    st.write("""
    Пусть требуется решить систему $A \\cdot \\vec{x} = \\vec{b}$. Обозначим расширенную матрицу со столбцами $\\vec{a}_1, \\vec{a}_2, \\dots, \\vec{a}_n, \\vec{b}$ через $A_0$:
    """)
    st.latex(r"""
    A_0 = \begin{pmatrix}
    a_{11}^{(0)} & a_{12}^{(0)} & \dots & a_{1n}^{(0)} & b_1^{(0)} \\
    a_{21}^{(0)} & a_{22}^{(0)} & \dots & a_{2n}^{(0)} & b_2^{(0)} \\
    \vdots & \vdots & \ddots & \vdots & \vdots \\
    a_{n1}^{(0)} & a_{n2}^{(0)} & \dots & a_{nn}^{(0)} & b_n^{(0)}
    \end{pmatrix}.
    """)

    st.write("""
    Будем преобразовывать ее по правилу:
    """)
    st.latex(r"""
    A_{k+1} = U_{k+1} A_k, \quad k = 0, 1, \dots, n-2,
    """)
    st.write("""
    с помощью последовательного умножения на матрицы $U_1, U_2, \dots, U_{n-1}$. Очевидно, что:
    """)
    st.latex(r"""
    \vec{a}_i^{(k+1)} = U_{k+1} \vec{a}_i^{(k)}.
    """)

    st.write("""
    Для $U_1$ выберем:
    """)
    st.latex(r"""
    \vec{S} = \vec{a}_1^{(0)} = (a_{11}, a_{12}, \dots, a_{1n}, b_1)^T, \quad \vec{I} = (1, 0, 0, \dots, 0)^T.
    """)

    st.write("""
    Тогда у вектора $\\vec{a}_1^{(0)}$ все координаты, кроме первой, будут равны нулю. Пусть уже построена матрица $A_k$, у которой $\\vec{a}_i^{(k)} = 0$ для $i > j$, где $j = 1, 2, \\dots, k$.

    Для построения матрицы $U_{k+1}$ в качестве $\\vec{S}_{k+1}$ выберем:
    """)
    st.latex(r"""
    \vec{S}_{k+1} = (0, 0, \dots, 0, a_{k+1}^{(k+1)}, a_{k+2}^{(k+1)}, \dots, a_n^{(k+1)}, b_{k+1}^{(k+1)})^T,
    """)
    st.latex(r"""
    \vec{I}_{k+1} = (0, 0, \dots, 0, 1, 0, \dots, 0)^T.
    """)

    st.write("""
    В этом случае:
    """)
    st.latex(r"""
    W = (0, 0, \dots, 0, W_{k+1}, W_{k+2}, \dots, W_n).
    """)

    st.write("""
    Для матрицы $U_k$ имеем:
    """)
    st.latex(r"""
    U_k = \begin{pmatrix}
    1 & 0 & 0 & \dots & 0 & 0 \\
    0 & 1 & 0 & \dots & 0 & 0 \\
    0 & 0 & 1 & \dots & 0 & 0 \\
    \vdots & \vdots & \vdots & \ddots & \vdots & \vdots \\
    0 & 0 & 0 & \dots & 1 & 0 \\
    0 & 0 & 0 & \dots & 0 & k
    \end{pmatrix}.
    """)

    st.write("""
    Для матрицы $A_{k+1}$ условие (14) будет выполнено и для $j = k+1$. При этом вектор $S$ не будет равен нулю для невырожденной матрицы $A$. После $(n-1)$ шага получим матрицу $A_{n-1}$, первые $n$ столбцов которой образуют верхнюю треугольную матрицу. Тогда:
    """)

    st.latex(r"""
    x_n = -\frac{a_{nn+1}^{(n-1)}}{a_{nn}^{(n-1)}};
    """)

    st.latex(r"""
    x_i = -\frac{a_{in+1}^{(n-1)} + \sum_{j=i+1}^{n} a_{ij}^{(n-1)} x_j}{a_{ii}^{(n-1)}}, \quad i = n-1, n-2, \dots, 1.
    """)

    st.write("""
    Этот метод похож на метод исключения Гаусса. Достоинством его является то, что вычисления делаются единообразно, без изменения порядка исключения. Метод отражений требует $\\frac{2}{3}n^3$ операций умножения, $\\frac{3}{2}n^3$ операций сложения, $-2n$ делений и $(n-1)$ извлечений квадратных корней, т.е. он вдвое дороже метода Гаусса.
    """)

def orthogonalization_method():

    st.title("6.4.3 Метод ортогонализации")

    st.write("""
    Этот метод был развит с целью решения плохо обусловленных систем, но также оказался не универсальным.
    Пусть требуется решить систему $A \\vec{x} = \\vec{b}$ порядка $n$. Запишем ее покоординатно в виде:
    """)

    st.latex(r"""
    \sum_{j=1}^{n} a_{ij} x_j + a_{in+1} = 0, \quad i = 1, 2, \dots, n,
    """)

    st.write("""
    где $a_{in+1} = b_i$. Обозначим через $\\vec{a}_i$ векторы размерности $n+1$, 
    $$ \\vec{a}_i = (a_{i1}, a_{i2}, \dots, a_{in}, a_{in+1})^T, \quad i = 1, 2, \dots, n, $$ 
    через $\\vec{y}$ обозначим вектор
    $$ \\vec{y} = (x_1, x_2, \dots, x_n, 1)^T. $$
    Тогда предыдущее уравнение можно переписать в виде скалярных произведений:
    """)

    st.latex(r"""
    (\vec{a}_i, \vec{y}) = 0, \quad i = 1, 2, \dots, n,
    """)

    st.write("""
    То есть решение линейной системы с невырожденной матрицей $A$ эквивалентно нахождению вектора $\\vec{y}$ размерности $n+1$ с последней координатой, равной единице, ортогонального векторам $\\vec{a}_i$, которые для невырожденной матрицы $A$ линейно независимы.

    Ортогональность к $\\vec{a}_i$ означает ортогональность к подпространству $R_n$, натянутому на них, и, следовательно, к любому его базису. Поэтому для решения системы достаточно найти вектор $\\vec{Z}$, ортогональный какому-либо базису в $R_n$, если $Z_{n+1} = 1$, его последняя координата.

    Пусть $\\vec{y} = Z/ Z_{n+1}$. Добавим к системе векторов $\\vec{a}_i, i = 1, 2, \dots, n$, независимый с ними вектор, например, $\\vec{a}_{n+1} = (0, 0, \dots, 0, 1)^T$ и ортогонализируем систему векторов $\\vec{a}_1, \\vec{a}_2, \dots, \\vec{a}_{n+1}$, используя процедуру Шмидта.

    Положим:
    """)

    st.latex(r"""
    \vec{C}_i = \frac{\vec{a}_i}{|\vec{a}_i|} = \frac{\vec{a}_i}{(\vec{a}_i, \vec{a}_i)^{1/2}}, \quad i = 1, 2, \dots, n,
    """)

    st.write("""
    Пусть построены взаимно ортогональные векторы $\\vec{C}_1, \\dots, \\vec{C}_k$, и надо построить нормированный вектор $\\vec{C}_{k+1}$, ортогональный к ним. Положим:
    """)

    st.latex(r"""
    U_{k+1} = a_{k+1} - \sum_{i=1}^{k} \alpha_i \vec{C}_i, \quad \alpha_i = (\vec{C}_i, \vec{a}_{k+1}), \quad i = 1, \dots, k;
    """)

    st.latex(r"""
    \vec{C}_{k+1} = \frac{U_{k+1}}{|U_{k+1}|}.
    """)

    st.write("""
    После определения системы векторов $\\vec{C}_1, \\dots, \\vec{C}_{n+1}$ решение исходной линейной системы получается по формуле:
    """)

    st.latex(r"""
    x_i = \frac{C_{n+1,i}}{C_{n+1, n+1}},
    """)

    st.write("""
    Этот метод требует порядка $n^3$ умножений, $n^3$ сложений, $n$ делений и $n$ извлечений корней.

    Основным недостатком метода ортогонализации является неустойчивость процесса ортогонализации по формуле (15) к ошибкам. Для того чтобы избавиться от неустойчивости процесса, применяется метод двойной ортогонализации, суть которого состоит в следующем: согласно очередному этапу ортогонализации, вычислим
    """)

    st.latex(r"""
    U_k = a_k - \sum_{i=1}^{k-1} \frac{(a_k, \vec{C}_i)}{(\vec{C}_i, \vec{C}_i)} \vec{C}_i,
    """)

    st.write("""
    а затем:
    """)

    st.latex(r"""
    \vec{C}_k = \frac{U_k}{|U_k|}.
    """)

    st.write("""
    Суммы в (16) и (17) надо считать с повышенной точностью, чтобы избежать излишнего накопления ошибок.
    """)

def square_root_method():
    st.title("6.4.4 Метод квадратного корня")

    st.write("""
    Этот метод ориентирован на систему с эрмитовой матрицей $A$, т.е. $A = A^H$. Если матрица $A$ — вещественная, то она должна быть симметричной. Метод основан на представлении $A$ в виде произведения:
    """)

    st.latex(r"""
    A = S^H D S, \quad (18)
    """)

    st.write("""
    где $D$ — диагональная матрица: $d_i = \pm 1$; $S$ — верхняя треугольная матрица $(S_{ik} = 0, i > k)$; $S^H$ — эрмитово сопряженная к ней. Потребуем для определенности разложения, что $S_{ii} > 0$.

    Определим элементы матриц $S, D$. Из (18) находим:
    """)

    st.latex(r"""
    a_{ii} = \sum_{i=1}^{i} (S^H)_{ki} d_i S_{ii} = \sum_{i=1}^{i} d_i |S_{ii}|^2,
    """)
    st.latex(r"""
    a_{ik} = \sum_{i=1}^{i} d_i S_{ki} S_{li}, \quad k < l.
    """)

    st.write("""
    Отсюда имеем:
    """)

    st.latex(r"""
    S_{ik} = sign \left( a_{ii} - \sum_{k=1}^{k-1} d_k |S_{ik}|^2 \right),
    """)
    st.latex(r"""
    S_{ik} = a_{ii} - \sum_{i=1}^{k-1} d_k S_{ik} S_{lk}, \quad k + 1 \leq n.
    """)

    st.write("""
    Полагаем сначала, что $k = 1$, и вычисляем все элементы первой строки матрицы $D$, затем полагаем, что $k = 2$, и вычисляем вторую строку и т.д.
    """)

    st.write("""
    Для $k = 1$:
    """)

    st.latex(r"""
    d_{11} = sign(a_{11}), \quad S_{ik} = \frac{a_{11}}{|S_{11}|}, \quad 2 \leq i \leq n.
    """)

    st.write("""
    Для $k = 2$:
    """)

    st.latex(r"""
    d_{22} = sign(a_{22} - S_{21} d_1 S_{21}), \quad S_{21} = \frac{a_{21}}{|S_{21}|}, \quad 2 \leq i \leq n.
    """)

    st.write("""
    После того как матрицы $S, D$ найдены, система $A \\vec{x} = \\vec{b}$ сводится к трем системам:
    """)

    st.latex(r"""
    S^H \vec{z} = \vec{b}, \quad D \vec{y} = \vec{z}, \quad S \vec{x} = \vec{y},
    """)

    st.write("""
    решение которых имеет вид:
    """)

    st.latex(r"""
    y_1 = \frac{b_1}{S_{11} d_{11}}, \quad y_i = \frac{b_i - \sum_{i=1}^{n} d_{ij} S_{ij}}{S_{ii} d_{ii}}, \quad i = 2, 3, \dots, n,
    """)
    st.latex(r"""
    x_i = \frac{y_i - \sum_{i=1}^{n} S_{ij} x_i}{S_{ii}}, \quad i = n, n-1, \dots, 1.
    """)

    st.write("""
    Определитель матрицы $A$ вычисляется по формуле:
    """)

    st.latex(r"""
    \text{det}(A) = \prod_{i=1}^{n} d_i |S_{ii}|^2.
    """)

    st.write("""
    Метод квадратного корня требует $\\frac{1}{6}n^3$ умножений, $\\frac{1}{6}n^3$ сложений, $n$ делений и $n$ извлечений квадратных корней; он в два раза быстрее метода Гаусса.

    **Замечание:** Если при некотором $k$ $S_{kk} = 0$, то надо найти $a_{il} \\neq 0$, $l > k$, и переставить $k$-е и $l$-е строки и столбцы.
    """)

def tridiagonal_matrix_algorithm():

    st.title("6.4.5 Метод прогонки")

    st.write("""
    Метод прогонки является наиболее важным частным случаем метода Гаусса и применяется к системам с трехдиагональной матрицей $A$. Такие системы обычно записывают в каноническом виде (в виде трехточечных уравнений):
    """)

    st.latex(r"""
    -a_i x_{i-1} + b_i x_i - c_i x_{i+1} = d_i, \quad 1 \leq i \leq n. \quad (20)
    """)

    st.write("""
    Именно такую систему мы получали при построении кубического интерполяционного сплайна.
    
    Если применить к уравнениям (20) метод исключения Гаусса, то при прямом ходе можно исключать только члены с элементами двух диагоналей, т.е. формулы обратного хода будут иметь вид:
    """)

    st.latex(r"""
    x_i = L_i x_{i+1} + k_i, \quad i = 1, 2, \dots, n-1 \quad (21)
    """)

    st.write("""
    где $L_i, k_i$ — прогонные коэффициенты. При этом очевидно, что:
    """)

    st.latex(r"""
    L_1 = \frac{c_1}{b_1}, \quad k_1 = \frac{d_1}{b_1}.
    """)

    st.write("""
    Из (20) при $i \geq 2$ имеем:
    """)

    st.latex(r"""
    a_i \left( L_i x_{i+1} + k_i \right) + b_i x_i - c_i x_{i+1} = d_i.
    """)

    st.write("""
    Отсюда, выразив $x_i$ через $x_{i+1}$, получим:
    """)

    st.latex(r"""
    x_i = \frac{c_i}{b_i - a_i L_{i-1}} x_{i+1} + \frac{d_i + a_i k_{i-1}}{b_i - a_i L_{i-1}}.
    """)

    st.write("""
    Сравнивая это выражение с (21), имеем:
    """)

    st.latex(r"""
    L_i = \frac{c_i}{b_i - a_i L_{i-1}}, \quad k_i = \frac{d_i + a_i k_{i-1}}{b_i - a_i L_{i-1}}. \quad (22)
    """)

    st.write("""
    По формулам (22) последовательно найдем $L_2, k_2, \dots, L_{n-1}, k_{n-1}$. Из последнего уравнения системы (20) получим:
    """)

    st.latex(r"""
    x_n = \frac{d_n + a_n k_{n-1}}{b_n - a_n L_{n-1}},
    """)

    st.write("""
    после чего по (21) определим все $x_i$, $i = n-1, \dots, 1$.
    
    Покажем, что если выполнено условие диагонального преобладания:
    """)

    st.latex(r"""
    |b_i| \geq |c_i| + |a_i|, \quad i = 1, 2, \dots, n, \quad (23)
    """)

    st.write("""
    то при прямом ходе не будет деления на нуль. Пусть при некотором $i$ $|L_i| < 1$. Тогда:
    """)

    st.latex(r"""
    |L_i| = \left| \frac{c_i}{b_i - a_i L_{i-1}} \right| \leq \frac{|c_i|}{|b_i| - |a_i| |L_{i-1}|} \leq 1.
    """)

    st.write("""
    При выполнении (23) формулы прогонки устойчивы относительно ошибок округления и позволяют решать уравнения с несколькими сотнями неизвестных.
    
    **Замечание:** Если прогонные коэффициенты $L_i, k_i$ найдены, то:
    """)

    st.latex(r"""
    \text{det}(A) = b_1 \prod_{i=2}^{n} \left( b_i - a_i L_{i-1} \right),
    """)

    st.write("""
    это легко видеть из прямого хода исключения метода Гаусса.
    """)

def runge_kutt():
        # Заголовок страницы
        st.title("11. Употребительные численные методы решения ОДУ")

        # Раздел 11.1
        st.header("11.1. Одношаговые методы решения ОДУ типа Рунге-Кутты")

        # Начальный текст
        st.write(
            """
            Большую часть материала мы будем давать применительно к решению задачи Коши для уравнения:
            """
        )
        st.latex(r"""
        y' = f(x, y), \quad y(x_0) = y_0"\tag{1}
        """)


        st.write(
            """
            оговаривая при необходимости особенности применения методов к системам уравнений. Пусть
            имеется некоторая сетка узлов $x_0, x_1, x_2, \dots, x_n, x_{n+1}, \dots$. В общем виде одношаговые 
            методы можно представить формулой:
            """
        )
        st.latex(r"""
        y_{n+1} = F(x_n, y_n, x_{n+1}, y_{n+1}\tag{2}
        """)

        st.write(
            """
            Такие общие одношаговые методы, используя информацию о решении в узле $x_n$, позволяют определить 
            приближение к решению в узле $x_{n+1}$. В этом разделе мы рассмотрим преимущественно явные одношаговые 
            методы, для которых $F$ в (2) не зависит от $y_{n+1}$. Для сокращения записи будем обозначать:
            """
        )
        st.latex(r"h = x_{n+1} - x_n \quad \text{и полагать} \quad n = 0.")

        st.write(
            """
            В принципе, решение уравнения (1) при $x = x_1$, зная его значение $y_0$ при $x = x_0$, можно 
            получить методом рядов Тейлора.
            """
        )
        st.write(
            "В самом деле, предположим, что $y(x)$ имеет непрерывные производные до порядка $(s+1)$ включительно. "
            "Тогда можно написать, что:"
        )
        st.latex(r"""
            y_1 = y_0 + hy_0' + \frac{h^2}{2} y_0'' + \dots + \frac{h^s}{s!} y_0^{(s)} + \frac{h^{s+1}}{(s+1)!} y_0^{(s+1)}(\xi)\tag{3}
        """)
        st.write("где:")

        st.latex(r"y_0^{(k)} = y^{(k)}(x_0), \quad x_0 < \xi < x_1.")

        st.markdown(
            """
            Входящие в (3) производные можно последовательно вычислить по формулам:
            """
        )

        st.latex(r"y_0' = f(x_0, y_0), \quad y_0'' = \left(f_x + f_y f\right)\big|_{x_0}, \quad \dots")

        # Ограничение метода Тейлора
        st.write(
            "С увеличением порядка производной выражение для неё сильно усложняется, "
            "ещё более громоздко оно для системы ОДУ. Поэтому ряды Тейлора при решении ОДУ практически не применяются."
        )
        st.write(
            """
            Рунге предложил приближённое решение $y_{1}$ в узле $x_{0} + h$ искать в виде:
            """
        )
        st.latex(r"""
            y_1 = y_0 + p_1 k_1(h) + p_2 k_2(h) + \dots + p_q k_q(h)\tag{4}
        """)
        st.markdown("**где:**")
        st.latex(r"""
            k_1 = h f(x_0, y_0), \quad
            k_2 = h f\left(x_0 + \alpha_2 h, y_0 + \beta_{2,1} k_1\right), \quad
            k_q = h f\left(x_0 + \alpha_q h, y_0 + \beta_{q,1} k_1 + \dots + \beta_{q,q-1} k_{q-1}\right).
        """)

        st.markdown(
            """
            Эти числа выбираются так, чтобы разложение выражения (4) в ряд по степеням $h$ совпадало 
            для произвольной функции $f(x, y)$ и производного $\phi(x, y)$ до максимально высокой степени с разложением (3).

            Введём вспомогательную функцию:
            """
        )
        st.latex(r"""
            \varphi_q(h) = y(x_0 + h) - y_0 - \sum_{i=1}^q P_i k_i(h)\tag{5}
        """)

        st.markdown(
            """
            Тогда сформулированное выше условие для выбора чисел $P_i, \\alpha_i, \\beta_{i,j}$ эквивалентно тому, 
            что разложение $\\varphi_q(h)$ по степеням $h$ должно начинаться с максимально высокой степени:
            """
        )
        st.latex(r"""
            \varphi_q(h) = \frac{h^{s+1}}{(s+1)!} a^{(s+1)}(0) + O(h^{s+2})\tag{6}
        """)

        st.subheader("Определение")
        st.markdown(
            """
            Пусть постоянные $\\alpha_i, \\beta_{i,j}, P_i$ в формуле (4) выбраны таким образом, что имеет место разложение (6). 
            Тогда говорят, что формула (4) имеет порядок точности $s$. Величина:
            """
        )
        st.latex(r"""
            \rho_{s+1} = \frac{h^{s+1}}{(s+1)!} a^{(s+1)}(0)
        """)
        st.markdown(
            """
            называется **главным членом погрешности метода на шаге $h$**.
            """
        )

def euler_method(f, x0, y0, x_end, h):
    """
    Решение ОДУ методом Эйлера.

    f: функция, задающая ОДУ dy/dx = f(x, y)
    x0: начальное значение x
    y0: начальное значение y
    x_end: конечное значение x
    h: шаг интегрирования

    Возвращает:
        x_vals: массив значений x
        y_vals: массив значений y
    """
    x_vals = [x0]
    y_vals = [y0]

    while x_vals[-1] < x_end:
        x, y = x_vals[-1], y_vals[-1]

        x_new = x + h
        y_new = y + h * f(x, y)

        x_vals.append(x_new)
        y_vals.append(y_new)

    return np.array(x_vals), np.array(y_vals)


def single_term_formulas():

        st.subheader("11.1.1. Одночленные формулы")

        st.markdown(
            """
            Положим в (4) $q = 1$, тогда решение в точке $x_0 + h$ будет отыскиваться в виде:
            """
        )
        st.latex(r"""
            y_1 = y_0 + P_1 k_1(h),
        """)
        st.markdown("где:")
        st.latex(r"""
            k_1(h) = h f(x_0, y_0).
        """)
        st.markdown(
            """
            В этом случае:
            """
        )
        st.latex(r"""
            \varphi_1(h) = y(x_0 + h) - y_0 - P_1 k_1(h),
        """)
        st.markdown("Используя ряд (3), находим:")
        st.latex(r"""
            \varphi_1(h) = h \left[1 - P_1\right] f(x_0, y_0) + \frac{h^2}{2} y_0'' + \dots
        """)
        st.markdown(
            """
            Очевидно, что $P_1 = 1$, и главный член погрешности равен:
            """
        )
        st.latex(r"""
            \rho_1 = \frac{h^2}{2} \left(f'_x + f'_y f\right)\big|_{x = x_0}.
        """)
        st.markdown(
            """
            Таким образом, одношаговая формула имеет вид:
            """
        )
        st.latex(r"""
            y_1 = y_0 + h f(x_0, y_0).
        """)
        st.markdown(
            """
            Это — известный метод Эйлера, он имеет первый порядок точности: $s = 1$.
            """
        )

        st.markdown("""
                **Пример использования метода Эйлера для решения ОДУ $y' = y - x^2 + 1$:**
                """)

        # Поля для ввода параметров
        x0 = st.number_input("Начальное значение x (x0):", value=0.0)
        y0 = st.number_input("Начальное значение y (y0):", value=1.0)
        x_end = st.number_input("Конечное значение x (x_end):", value=5.0)
        h = st.number_input("Шаг интегрирования (h):", value=0.1)

        if st.button("Рассчитать решение"):
            # Определение функции
            f = lambda x, y: y - x ** 2 + 1

            # Вычисление решения методом Эйлера
            x_vals, y_vals = euler_method(f, x0, y0, x_end, h)

            # Построение графика
            fig, ax = plt.subplots()
            ax.plot(x_vals, y_vals, label="Решение методом Эйлера", marker="o")
            ax.set_title("Решение ОДУ методом Эйлера")
            ax.set_xlabel("x")
            ax.set_ylabel("y")
            ax.legend()
            ax.grid()
            st.pyplot(fig)

     # Вывод таблицы с результатами
            results = pd.DataFrame({"x": x_vals, "y": y_vals})
            st.markdown("### Результаты интегрирования")
            st.dataframe(results, use_container_width=True)

if __name__ == "__main__":
        single_term_formulas()

def runge_kutta_2(f, x0, y0, x_end, h, alpha2):
    """
    Решение ОДУ методом Рунге-Кутты 2-го порядка.

    f: функция, задающая ОДУ dy/dx = f(x, y)
    x0: начальное значение x
    y0: начальное значение y
    x_end: конечное значение x
    h: шаг интегрирования
    alpha2: параметр схемы Рунге-Кутты второго порядка

    Возвращает:
        x_vals: массив значений x
        y_vals: массив значений y
    """
    x_vals = [x0]
    y_vals = [y0]

    while x_vals[-1] < x_end:
        x, y = x_vals[-1], y_vals[-1]

        k1 = h * f(x, y)
        k2 = h * f(x + alpha2 * h, y + alpha2 * k1)
        y_new = y + (1 - 1 / (2 * alpha2)) * k1 + (1 / (2 * alpha2)) * k2

        x_new = x + h

        x_vals.append(x_new)
        y_vals.append(y_new)

    return np.array(x_vals), np.array(y_vals)

def two_term_formulas():
        st.subheader("11.1.2. Двухчленные формулы")

        st.markdown(
            """
            Положим в (4) $q = 2$. Тогда решение в точке $x_0 + h$ будет отыскиваться в виде:
            """
        )
        st.latex(r"""
            y_1 = y_0 + P_{21} k_1(h) + P_{22} k_2(h),
        """)
        st.markdown("где:")
        st.latex(r"""
            k_1(h) = h f(x_0, y_0), \quad
            k_2(h) = h f\left(x_0 + \alpha_2 h, y_0 + \beta_{21} k_1\right).
        """)
        st.markdown(
            """
            У нас в распоряжении четыре параметра. Для их определения составим:
            """
        )
        st.latex(r"""
            \varphi_2(h) = y(x_0 + h) - y_0 - P_{21} k_1(h) - P_{22} k_2(h).
        """)
        st.markdown("Разложим её в ряд по $h$:")
        st.latex(r"""
            \varphi_2(0) = 0, \quad
            \varphi_2'(h) = y' - P_{21} f(x_0, y_0) - P_{22} f\left(x_0 + \alpha_2 h, y_0 + \beta_{21} k_1\right),
        """)
        st.latex(r"""
            \varphi_2'(0) = f(x_0, y_0) \left[1 - P_{21} - P_{22}\right].
        """)
        st.markdown(
            """
            Для второй производной имеем:
            """
        )
        st.latex(r"""
            \varphi_2''(h) = y_0'' - 2 P_{22} \left[\alpha_2 f_x + \beta_{21} f_y f\right].
        """)
        st.latex(r"""
            \varphi_2''(0) = y_0'' - 2 P_{22} \left[\alpha_2 f_x + \beta_{21} f_y f\right].
        """)
        st.markdown(
            """
            Заменяя $y_0''$ выражением через $f$ и производные, получим:
            """
        )
        st.latex(r"""
            \varphi_2''(0) = (1 - 3 \alpha_2 P_{22}) f_x + 2 (1 - 3 \alpha_2 P_{22}) f_y f + 
            \left(1 - 3 \beta_{21}^2 P_{22}\right) f_y^2 + (f_x' + f_y' f).
        """)
        st.markdown(
            """
            Из условия $\\varphi_2'(0) = 0$ имеем:
            """
        )
        st.latex(r"""
            1 - P_{21} - P_{22} = 0.
        """)
        st.markdown(
            """
            Из условия $\\varphi_2''(0) = 0$ получаем два уравнения:
            """
        )
        st.latex(r"""
            1 - 2 \alpha_2 P_{22} = 0, \quad
            1 - 2 \beta_{21} P_{22} = 0.
        """)

        st.markdown(
            """
            Если мы попытаемся положить $\\varphi_2''(0) = 0$, то получим, что последнее слагаемое нельзя занулить для произвольной $f(x, y)$. 
            Поэтому $\\varphi_2''(0)$ занулить при произвольной $f$ нельзя. 

            Из полученных уравнений имеем:
            """
        )

        st.latex(r"""
        \alpha_2 \neq 0; \quad \beta_{21} \neq 0; \quad \alpha_2 = \beta_{21}.
        """)

        st.markdown(
            """
            Примем $\\alpha_2$ за свободный параметр. Тогда:
            """
        )
        st.latex(r"""
            \beta_{21} = \alpha_2, \quad
            P_{22} = \frac{1}{2 \alpha_2}, \quad
            P_{21} = 1 - \frac{1}{2 \alpha_2}.
        """)

        st.markdown(
            """
            Таким образом, мы получили однопараметрическое семейство схем Рунге—Кутты второго порядка точности. При этом:
            """
        )
        st.latex(r"""
            \rho_1 = \frac{h^3}{6} \left(1 - \frac{3}{2} \alpha_2\right) f_x + 2 f_y f.
        """)

        st.markdown(
            """
            Рассмотрим частные случаи:
            """
        )
        st.markdown(
            """
            1. **$\\alpha_2 = 1$.** Тогда схема принимает вид (схема Хойна):
            """
        )
        st.latex(r"""
            y_1 = y_0 + \frac{1}{2} \left(k_1 + k_2\right),
            """)
        st.latex(r"""
            \quad k_1 = h f(x_0, y_0),\tag{7}
        """)

        st.latex(r"""
            \quad k_2 = h f(x_0 + h, y_0 + k_1).
        """)

        st.markdown("Главный член погрешности равен:")

        st.latex(r"""
            \rho_1 = \frac{h^3}{6} \left(f_x + 2 f_y f + f_y f_x + f_{yy} f^2\right).
        """)

        st.markdown(
            """
            В схеме Хойна, в отличие от метода Эйлера, в точке $(x_0, y_0)$ проводится не касательная, 
            а прямая с угловым коэффициентом, равным полусумме угловых коэффициентов касательных в узлах $x_0$ и $x_1$. 
            Если $f$ не зависит от $y$, получаем формулу трапеции.
            """
        )

        st.markdown(
            """
            2. **$\\alpha_2 = \\frac{1}{2}$.** Схема принимает вид:
            """
        )
        st.latex(r"""
            y_1 = y_0 + k_2, \quad
        """)

        st.latex(r"""
            k_1 = h f(x_0, y_0), \quad\tag{8}
        """)

        st.latex(r"""
            k_2 = h f\left(x_0 + \frac{h}{2}, y_0 + \frac{1}{2} k_1\right).
        """)

        st.markdown("Главный член погрешности равен:")
        st.latex(r"""
        \rho_1 = \frac{h^3}{6} \left( \frac{1}{2} f_{xx} + 2 f_{xy}' + f_y f_{yy}' \right) .
        """)

        st.markdown(
            """
            Если $f$ не зависит от $y$, то получается формула центральных прямоугольников.
            """
        )

        st.markdown(
            """
            3. **$\\alpha_2 = \\frac{2}{3}$.** При этом получается схема:
            """
        )

        st.latex(r"""
        y_1 = y_0 + \frac{1}{4}(k_1 + 3k_2), \quad
        """)

        st.latex(r"""
        k_1 = h f(x_0, y_0), \quad\tag{9}
        """)

        st.latex(r"""
        k_2 = h f \left( x_0 + \frac{2}{3}h, y_0 + \frac{2}{3} k_1 \right).
        """)

        st.markdown("**Главный член погрешности равен:**")
        st.latex(r"""
        \rho_1 = \frac{h^3}{6} \left(f_x + f_y f\right).
        """)

        st.markdown(
            """
            Отметим, что если $f$ не зависит от $y$, то главный член погрешности становится равным 0. 
            Однако, вообще говоря, отдать предпочтение заранее какой-либо из схем невозможно.
            """
        )

        st.markdown("""
            **Пример использования метода Рунге-Кутты второго порядка для решения ОДУ $y' = y - x^2 + 1$:**
            """)

        # Поля для ввода параметров
        x0 = st.number_input("Начальное значение x (x0):", value=0.0)
        y0 = st.number_input("Начальное значение y (y0):", value=0.5)
        x_end = st.number_input("Конечное значение x (x_end):", value=2.0)
        h = st.number_input("Шаг интегрирования (h):", value=0.1)
        alpha2 = st.number_input("Параметр \( \alpha_2 \):", value=0.5)

        if st.button("Рассчитать решение"):
            # Определение функции
            f = lambda x, y: y - x ** 2 + 1

            # Вычисление решения методом Рунге-Кутты второго порядка
            x_vals, y_vals = runge_kutta_2(f, x0, y0, x_end, h, alpha2)

            # Отображение текста с ОДУ
            st.markdown("### Решается ОДУ: $y' = y - x^2 + 1$")

            # Построение графика
            fig, ax = plt.subplots()
            ax.plot(x_vals, y_vals, label="Решение методом Рунге-Кутты 2-го порядка", marker="o")
            ax.set_title("Решение ОДУ методом Рунге-Кутты 2-го порядка")
            ax.set_xlabel("x")
            ax.set_ylabel("y")
            ax.legend()
            ax.grid()

            st.pyplot(fig)

            # Вывод таблицы с результатами
            results = pd.DataFrame({"x": x_vals, "y": y_vals})
            st.markdown("### Результаты интегрирования")
            st.dataframe(results, use_container_width=True)


if __name__ == "__main__":
    two_term_formulas()

def runge_kutta_3(f, x0, y0, x_end, h):
    """
    Решение ОДУ методом Рунге-Кутты 3-го порядка.

    f: функция, задающая ОДУ dy/dx = f(x, y)
    x0: начальное значение x
    y0: начальное значение y
    x_end: конечное значение x
    h: шаг интегрирования

    Возвращает:
        x_vals: массив значений x
        y_vals: массив значений y
    """
    x_vals = [x0]
    y_vals = [y0]

    while x_vals[-1] < x_end:
        x, y = x_vals[-1], y_vals[-1]

        k1 = h * f(x, y)
        k2 = h * f(x + h / 2, y + k1 / 2)
        k3 = h * f(x + 2 * h / 3, y + k1 / 3 + k2 / 3)

        y_new = y + (1 / 6) * k1 + (4 / 6) * k2 + (1 / 6) * k3
        x_new = x + h

        x_vals.append(x_new)
        y_vals.append(y_new)

    return np.array(x_vals), np.array(y_vals)


def three_term_formulas():
        st.header("11.1.3. Трёхчленные формулы")

        st.markdown("""
        Положим в (4) $q = 3$. Тогда решение в точке $x_0 + h$ будет отыскиваться в виде:
        """)
        st.latex(r"y_1 = y_0 + P_{31} k_1(h) + P_{32} k_2(h) + P_{33} k_3(h),")

        st.markdown("где")

        st.latex(r"""
        k_1 = h f(x_0, y_0);
        """)

        st.latex(r""" \quad
        k_2 = h f\left(x_0 + \alpha_2 h, \, y_0 + \beta_{21} k_1\right)\tag{10};
        """)

        st.latex(r""" \quad
        k_3 = h f\left(x_0 + \alpha_3 h, \, y_0 + \beta_{31} k_1 + \beta_{32} k_2\right).
        """)

        st.markdown("""
        У нас в распоряжении восемь параметров, которые можно выбрать так, чтобы:
        """)
        st.latex(r"\varphi_3(h) = \frac{h^4}{24} \varphi^{(4)}(0) + O(h^5).")

        st.markdown("Уравнения для этих параметров имеют вид:")
        st.latex(r"""
        \alpha_2 = \beta_{21}; 
        """)

        st.latex(r"""
        \quad \alpha_3 = \beta_{31} + \beta_{32};
        """)

        st.latex(r""" \quad
        P_{31} + P_{32} + P_{33} = 1; 
        """)

        st.latex(r""" \quad
        2 \left(\alpha_2 P_{32} + \alpha_3 P_{33}\right) = 1\tag{11};
        """)

        st.latex(r"""
        3 \left(\alpha_2^2 P_{32} + \alpha_3^2 P_{33}\right) = 1;
        """)

        st.latex(r""" \quad
        6 \alpha_2 \beta_{32} P_{33} = 1.
        """)

        st.markdown("""
        Эта система имеет два семейства решений:
        - двухпараметрическое с параметрами $\\alpha_2$, $\\alpha_3$;
        - однопараметрическое с параметром $\\beta_{32}$ (при $\\alpha_2 = \\alpha_3 = 2/3$).
    
        Рассмотрим частный случай: $\\alpha_2 = 1/2$, $\\alpha_3 = 1$, $\\beta_{32} = 2/3$. Тогда:
        """)

        st.latex(r"""
        y_1 = y_0 + \frac{1}{6}(k_1 + 4k_2 + k_3);
        """)

        st.latex(r"""\quad
        k_1 = h f(x_0, y_0)\tag{12}; 
        """)

        st.latex(r""" \quad
        k_2 = h f\left(x_0 + \frac{1}{2} h, \, y_0 + \frac{1}{2} k_1\right);
        """)

        st.latex(r""" \quad
        k_3 = h f\left(x_0 + h, \, y_0 + 2k_2 - k_1\right).
        """)

        st.markdown("""
        При $f$, не зависящей от $y$, имеем формулу интегрирования Симпсона.
        """)

        st.markdown("""
                **Пример использования метода Рунге-Кутты третьего порядка для решения ОДУ $y' = y - x^2 + 1$:**
                """)

        # Поля для ввода параметров
        x0 = st.number_input("Начальное значение x (x0):", value=0.0)
        y0 = st.number_input("Начальное значение y (y0):", value=0.5)
        x_end = st.number_input("Конечное значение x (x_end):", value=2.0)
        h = st.number_input("Шаг интегрирования (h):", value=0.1)

        if st.button("Рассчитать решение"):
            # Определение функции
            f = lambda x, y: y - x ** 2 + 1

            # Вычисление решения методом Рунге-Кутты третьего порядка
            x_vals, y_vals = runge_kutta_3(f, x0, y0, x_end, h)

            # Отображение текста с ОДУ
            st.markdown("### Решается ОДУ: $y' = y - x^2 + 1$")

            # Построение графика
            fig, ax = plt.subplots()
            ax.plot(x_vals, y_vals, label="Решение методом Рунге-Кутты 3-го порядка", marker="o")
            ax.set_title("Решение ОДУ методом Рунге-Кутты 3-го порядка")
            ax.set_xlabel("x")
            ax.set_ylabel("y")
            ax.legend()
            ax.grid()

            st.pyplot(fig)

            # Вывод таблицы с результатами
            results = pd.DataFrame({"x": x_vals, "y": y_vals})
            st.markdown("### Результаты интегрирования")
            st.dataframe(results, use_container_width=True)


if __name__ == "__main__":
    three_term_formulas()


def runge_kutta_4(f, x0, y0, x_end, h):
    """
    Решение ОДУ методом Рунге-Кутты 4-го порядка.

    f: функция, задающая ОДУ dy/dx = f(x, y)
    x0: начальное значение x
    y0: начальное значение y
    x_end: конечное значение x
    h: шаг интегрирования

    Возвращает:
        x_vals: массив значений x
        y_vals: массив значений y
    """
    x_vals = [x0]
    y_vals = [y0]

    while x_vals[-1] < x_end:
        x, y = x_vals[-1], y_vals[-1]

        k1 = h * f(x, y)
        k2 = h * f(x + h / 2, y + k1 / 2)
        k3 = h * f(x + h / 2, y + k2 / 2)
        k4 = h * f(x + h, y + k3)

        y_new = y + (1 / 6) * k1 + (1 / 3) * k2 + (1 / 3) * k3 + (1 / 6) * k4
        x_new = x + h

        x_vals.append(x_new)
        y_vals.append(y_new)

    return np.array(x_vals), np.array(y_vals)


def four_term_formulas():
    st.header("11.1.4. Четырехчленные формулы. Перенос на системы ОДУ")

    st.markdown("""
        **Положим в (4)** $$ q = 4 $$. Существует семейство формул типа Рунге-Кутты четвертого порядка точности, для которых главный член погрешности
        имеет вид:
        """)
    st.latex(r"""
        \rho_1 = \frac{h^5}{120} \varphi^{(5)}(0).
        """)
    st.markdown("**Классической является схема вида:**")
    st.latex(r"""
        y_1 = y_0 + \frac{h}{6} \left( k_1 + 2k_2 + 2k_3 + k_4 \right),
        """)
    st.latex(r"""
        k_1 = h f(x_0, y_0);
        """)
    st.latex(r""" \quad
        k_2 = h f\left(x_0 + \frac{1}{2}h, y_0 + \frac{1}{2}k_1\right)\tag{13};
        """)
    st.latex(r"""
        k_3 = h f\left(x_0 + \frac{1}{2}h, y_0 + \frac{1}{2}k_2\right);
        """)
    st.latex(r""" \quad
        k_4 = h f\left(x_0 + h, y_0 + k_3\right).
        """)
    st.markdown("""
        **Все методы Рунге – Кутты легко переносятся на системы ОДУ вида:**
        """)
    st.latex(r"""
        \frac{d\bar{y}}{dx} = \bar{f}(x, \bar{y}),
        """)
    st.markdown("где")
    st.latex(r"""
        \bar{y} = \begin{pmatrix} y_1 \\ y_2 \\ \vdots \\ y_M \end{pmatrix}, \quad
        \bar{f} = \begin{pmatrix} f_1(x, y_1, \dots, y_M) \\ f_2(x, y_1, \dots, y_M) \\ \vdots \\ f_M(x, y_1, \dots, y_M) \end{pmatrix}.
        """)
    st.markdown("""
        **Схемы имеют вид:**
        """)
    st.latex(r"""
        \bar{y}_{n+1} = \bar{y}_n + P_{q1} k_1(h) + \dots + P_{qq} \bar{k}_q(h),
        """)

    st.markdown("где")

    st.latex(r"""
        \bar{k}_1 = h \bar{f}(x_n, \bar{y}_n),
        """)

    st.latex(r""" \quad
        \bar{k}_2 = h \bar{f}\left(x_n + \alpha_2 h, \bar{y}_n + \beta_{21} \bar{k}_1(h)\right),
        """)

    st.latex(r"""
        \bar{k}_q = h \bar{f}\left(x_n + \alpha_q h, \bar{y}_n + \beta_{q1}\bar{k}_1 + \dots + \beta_{q,q-1}\bar{k}_{q-1}\right).
        """)

    st.markdown("""
        **Пример использования метода Рунге-Кутты четвёртого порядка для решения ОДУ $y' = y - x^2 + 1$:**
        """)

    # Поля для ввода параметров
    x0 = st.number_input("Начальное значение x (x0):", value=0.0)
    y0 = st.number_input("Начальное значение y (y0):", value=0.5)
    x_end = st.number_input("Конечное значение x (x_end):", value=2.0)
    h = st.number_input("Шаг интегрирования (h):", value=0.1)

    if st.button("Рассчитать решение"):
        # Определение функции
        f = lambda x, y: y - x**2 + 1

        # Вычисление решения методом Рунге-Кутты четвёртого порядка
        x_vals, y_vals = runge_kutta_4(f, x0, y0, x_end, h)

        # Отображение текста с ОДУ
        st.markdown("### Решается ОДУ: $y' = y - x^2 + 1$")

        # Построение графика
        fig, ax = plt.subplots()
        ax.plot(x_vals, y_vals, label="Решение методом Рунге-Кутты 4-го порядка", marker="o")
        ax.set_title("Решение ОДУ методом Рунге-Кутты 4-го порядка")
        ax.set_xlabel("x")
        ax.set_ylabel("y")
        ax.legend()
        ax.grid()

        st.pyplot(fig)

        # Вывод таблицы с результатами
        results = pd.DataFrame({"x": x_vals, "y": y_vals})
        st.markdown("### Результаты интегрирования")
        st.dataframe(results, use_container_width=True)

if __name__ == "__main__":
    four_term_formulas()