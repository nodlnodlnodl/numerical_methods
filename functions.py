import streamlit as st
import numpy as np
import matplotlib.pyplot as plt
from streamlit_ace import st_ace

from scipy.integrate import odeint
from scipy.optimize import fsolve
import time

import time
import io
import sys


def general_rules():
    st.header("1. Общие правила вычислительной работы")

    st.markdown("""
        При выполнении вычислительных задач важно придерживаться некоторых основных принципов, чтобы обеспечить точность, эффективность и повторяемость результатов:

        - **Чистота кода:** Код должен быть чистым и понятным. Это упрощает его проверку и уменьшает вероятность ошибок.
        - **Комментарии:** Всегда комментируйте ваш код. Это помогает другим (и вам самим в будущем) понять, что именно делает ваш код.
        - **Тестирование:** Регулярно тестируйте свой код на различных данных, чтобы убедиться, что он работает корректно.
        - **Оптимизация:** Ищите способы оптимизации вашего кода для улучшения производительности, особенно если обрабатываются большие объемы данных.
        - **Документация:** Поддерживайте актуальную документацию для вашего кода и проекта, описывая основные функции, используемые библиотеки и зависимости.
        - **Версионирование:** Используйте системы контроля версий, такие как Git, для отслеживания изменений в вашем коде и облегчения совместной работы.
        """)

    st.code("""
        # Пример функции с документацией и комментариями
        def calculate_area(base, height):
            '''
            Рассчитывает площадь треугольника по основанию и высоте.

            Параметры:
            base (float): Основание треугольника.
            height (float): Высота треугольника.

            Возвращает:
            float: Площадь треугольника.
            '''
            # Формула для расчета площади треугольника
            area = 0.5 * base * height
            return area
        """, language='python')


def inaccuracy():
    st.header("2. Источники и классификация погрешности")

    st.markdown("""
    В процессе численных расчетов погрешности могут возникать из различных источников и иметь различную природу. Классификация погрешностей включает в себя:

    - **Абсолютная погрешность:** Разница между точным значением и приближенным, измеренным или вычисленным значением.
    - **Относительная погрешность:** Отношение абсолютной погрешности к точному значению, часто выражается в процентах.
    - **Погрешность действий:** Погрешности, возникающие в результате выполнения арифметических операций, особенно при работе с числами с плавающей запятой в компьютерных вычислениях.

    ### Общая формула погрешности
    Общая формула для абсолютной и относительной погрешности может быть выражена в LaTeX как:
    """)

    st.latex(r"""
    \text{Абсолютная погрешность:} \quad \Delta x = |x_{\text{точное}} - x_{\text{приближенное}}|
    """)

    st.latex(r"""
    \text{Относительная погрешность:} \quad \varepsilon = \frac{\Delta x}{|x_{\text{точное}}|}
    """)

    st.latex(r"""
    \text{Где} \ (\Delta x) \ \text{— абсолютная погрешность,} \ (\varepsilon) \ \text{— относительная погрешность,}\\ \ (x_{\text{точное}}) \ \text{— точное значение,} \ (x_{\text{приближенное}}) \ \text{— приближенное значение.}
    """)

    st.markdown("""
    Понимание и учет этих погрешностей критически важно для достижения точности и надежности численных методов.
    """)


def general_rules_for_approximating_functions():
    st.header("3. Общие правила приближения функций")

    st.markdown("""
        При работе с численными методами приближения функций важно учитывать следующие аспекты:

        - **Выбор метода:** Выбор подходящего метода зависит от типа и свойств функции, а также от требуемой точности.
        - **Точность и сходимость:** Необходимо оценить, как быстро метод сходится к точному решению и какова его точность при различном количестве узлов или итераций.
        - **Вычислительная сложность:** Рассмотрение времени выполнения и требуемых ресурсов для каждого метода важно при больших объемах данных.
        - **Устойчивость метода:** Важно анализировать, насколько метод устойчив к ошибкам округления и входным погрешностям.
        """)


def lagrange_for_interpolation():
    st.header("4. Метод Лагранжа для интерполяции")

    st.markdown("""
        Метод Лагранжа — это форма полиномиальной интерполяции, используемая для аппроксимации функций. Полином Лагранжа представляет собой линейную комбинацию базисных полиномов Лагранжа, что позволяет точно проходить через заданные точки.
        """)

    st.latex(r"""
        \textbf{Теоретическая основа:} \\
        Полином \, Лагранжа \, L(x) \, для \, n \, точек \, задаётся \, формулой: \\
        L(x) = \sum_{i=0}^{n-1} y_i \ell_i(x)
        """)
    st.latex(r"""
        где \, \ell_i(x) \, — базисные \, полиномы \, Лагранжа, \, определённые \, как: \\
        \ell_i(x) = \prod_{\substack{j=0 \\ j \neq i}}^{n-1} \frac{x - x_j}{x_i - x_j}
        """)

    st.markdown("**Реализация на чистом Python:**")
    st.code("""
    def lagrange_interpolation(x, x_points, y_points):
        total = 0
        n = len(x_points)
        for i in range(n):
            term = y_points[i]
            for j in range(n):
                if i != j:
                    term *= (x - x_points[j]) / (x_points[i] - x_points[j])
            total += term
        return total

    # Пример узлов и значений
    x_points = [1, 2, 3, 4, 5]  # Узлы x
    y_points = [1, 4, 9, 16, 25]  # Значения y в этих узлах (x^2)

    # Тестирование интерполяции в точке x = 2.5
    interpolated_value = lagrange_interpolation(2.5, x_points, y_points)
    print("Интерполированное значение в x = 2.5:", interpolated_value)
        """)

    st.markdown("""
        Этот код демонстрирует базовую реализацию метода Лагранжа для интерполяции на языке Python. 
        Пользователь может изменить узлы интерполяции и точки, чтобы исследовать, как метод справляется с различными наборами данных.
        """)

    st.markdown("**Преимущества:**")
    st.markdown("""
        - Простота реализации.
        - Точное совпадение с интерполируемыми данными.
        """)

    st.markdown("**Недостатки:**")
    st.markdown("""
        - Не устойчив при большом количестве узлов из-за феномена Рунге.
        - Высокая вычислительная стоимость при увеличении числа узлов.
        """)

    st.markdown("**Алгоритм:**")
    st.latex(r"""
        1. \, Выбрать \, узлы \, интерполяции \, x_i \, и \, соответствующие \, значения \, y_i. \\
        2. \, Для \, каждого \, x \, в \, области \, определения \, вычислить \, L(x) \, с \, помощью \, базисных \, полиномов. \\
        3. \, Использовать \, L(x) \, для \, аппроксимации \, или \, интерполяции \, между \, узлами.
        """)

    # Демонстрация работы метода Лагранжа
    def f(x):
        return np.sin(x)

    def lagrange_interpolation(x, x_points, y_points):
        total = 0
        n = len(x_points)
        for i in range(n):
            term = y_points[i]
            for j in range(n):
                if i != j:
                    term = term * (x - x_points[j]) / (x_points[i] - x_points[j])
            total += term
        return total

    num_points = st.slider("Выберите количество узлов интерполяции", 1, 20, 4)
    x_points = np.linspace(0, 2 * np.pi, num_points)
    y_points = f(x_points)
    x_range = np.linspace(0, 2 * np.pi, 100)
    y_approx = [lagrange_interpolation(x, x_points, y_points) for x in x_range]

    fig, ax = plt.subplots()
    ax.plot(x_range, f(x_range), label='Исходная функция')
    ax.plot(x_range, y_approx, label='Приближение Лагранжа')
    ax.scatter(x_points, y_points, color='red', label='Узлы интерполяции')
    ax.legend()
    st.pyplot(fig)


def newton_for_interpolation():
    st.header("5. Метод Ньютона для интерполяции")

    st.markdown("""
        Метод Ньютона — это форма полиномиальной интерполяции, которая использует разделённые разности для построения интерполяционного полинома. Он позволяет последовательно добавлять новые узлы интерполяции без пересчёта всех коэффициентов, что делает метод более удобным для вычислений.
        """)

    st.latex(r"""
        \textbf{Теоретическая основа:} \\
        Полином \, Ньютона \, P_n(x) \, для \, n \, точек \, задаётся \, формулой: \\
        P_n(x) = f(x_0) + f[x_0, x_1](x - x_0) + \dots + f[x_0, x_1, ..., x_n](x - x_0) \cdot (x - x_1) \cdot ... \cdot (x - x_{n-1})
        """)
    st.latex(r"""
        где \, f[x_0, x_1, ..., x_k] \, — разделённые \, разности, \, определённые \, как: \\
        f[x_i] = y_i, \, f[x_i, x_{i+1}] = \frac{y_{i+1} - y_i}{x_{i+1} - x_i}, \dots
        """)

    st.markdown("**Реализация на чистом Python:**")
    st.code("""
    def divided_differences(x, y):
        #Функция для вычисления таблицы разделённых разностей.
        n = len(x)
        coef = [[0 for _ in range(n)] for _ in range(n)]
        for i in range(n):
            coef[i][0] = y[i]

        for j in range(1, n):
            for i in range(n - j):
                coef[i][j] = (coef[i + 1][j - 1] - coef[i][j - 1]) / (x[i + j] - x[i])

        return [coef[0][i] for i in range(n)]

    def newton_polynomial(x_data, y_data, x):
        #Функция для вычисления значения полинома Ньютона в точке.
        coef = divided_differences(x_data, y_data)
        n = len(coef)
        result = coef[-1]
        for i in range(n - 2, -1, -1):
            result = coef[i] + (x - x_data[i]) * result
        return result

    # Пример узлов и значений
    x_data = [1, 2, 3, 4]
    y_data = [1, 8, 27, 64]  # Значения y = x^3

    # Тестирование интерполяции в точке x = 2.5
    interpolated_value = newton_polynomial(x_data, y_data, 2.5)
    print("Интерполированное значение в x = 2.5:", interpolated_value)
        """)

    st.markdown("""
        Этот код демонстрирует реализацию метода Ньютона для интерполяции на языке Python. 
        Он использует разделённые разности для вычисления коэффициентов интерполяционного полинома и вычисления значения полинома в нужной точке.
        """)

    st.markdown("**Преимущества:**")
    st.markdown("""
        - Удобство добавления новых узлов интерполяции без пересчёта всех коэффициентов.
        - Меньшая вычислительная сложность по сравнению с другими методами при добавлении узлов.
        """)

    st.markdown("**Недостатки:**")
    st.markdown("""
        - Неустойчив при большом числе узлов (как и метод Лагранжа).
        - Зависимость от порядка введения узлов.
        """)

    st.markdown("**Алгоритм:**")
    st.latex(r"""
        1. \, Выбрать \, узлы \, интерполяции \, x_i \, и \, соответствующие \, значения \, y_i. \\
        2. \, Построить \, таблицу \, разделённых \, разностей \, f[x_i, ..., x_j]. \\
        3. \, Для \, каждого \, x \, в \, области \, определения \, вычислить \, P_n(x).
        """)

    # Демонстрация работы метода Ньютона для интерполяции с возможностью добавления новых точек

    def compute_divided_differences(x_data, y_data):
        """ Вычисление таблицы разделённых разностей. """
        n = len(x_data)
        dd_table = [[0 for _ in range(n)] for _ in range(n)]
        for i in range(n):
            dd_table[i][0] = y_data[i]

        for j in range(1, n):
            for i in range(n - j):
                dd_table[i][j] = (dd_table[i + 1][j - 1] - dd_table[i][j - 1]) / (x_data[i + j] - x_data[i])

        return dd_table

    def newton_polynomial(x_data, y_data, x, dd_table):
        """ Вычисление значения полинома Ньютона в точке x. """
        n = len(x_data)
        result = dd_table[0][0]
        for i in range(1, n):
            product = 1
            for j in range(i):
                product *= (x - x_data[j])
            result += dd_table[0][i] * product
        return result

    # Заданные точки для интерполяции
    x_points = [1, 2, 3, 4, 5]
    y_points = [1, 8, 27, 64, 125]  # Значения y = x^3

    # Функция для обновления графика и таблицы
    def update_plot_and_table(x_points, y_points):
        dd_table = compute_divided_differences(x_points, y_points)
        x_range = [min(x_points) + i * (max(x_points) - min(x_points)) / 100 for i in range(101)]
        y_approx = [newton_polynomial(x_points, y_points, x, dd_table) for x in x_range]

        st.write("Таблица разделённых разностей:")
        st.dataframe(dd_table)

        fig, ax = plt.subplots()
        ax.plot(x_range, y_approx, label='Приближение Ньютона')
        ax.scatter(x_points, y_points, color='red', label='Узлы интерполяции')
        ax.legend()
        st.pyplot(fig)

    # Интерфейс для добавления новых точек
    st.header("Добавление новых точек для интерполяции")
    col1, col2 = st.columns(2)
    with col1:
        new_x = st.number_input("Введите значение x:", format="%f", key="x_input")
    with col2:
        new_y = st.number_input("Введите значение y:", format="%f", key="y_input")

    if st.button("Добавить точку"):
        x_points.append(new_x)
        y_points.append(new_y)
        print("x=", x_points, "; y=", y_points)

    update_plot_and_table(x_points, y_points)
